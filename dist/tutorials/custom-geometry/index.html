<!DOCTYPE html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_astro/_slug_.C79K3bky.css rel=stylesheet /></head><body><nav><ul><a href=/ >Home</a> <a href=/reference>Reference</a> <a href=/tutorials>Tutorials</a> <a href=/examples>Examples</a> <a href=/community>Community</a> <a href=/about>About</a> <a href=/contribute>Contribute</a></ul></nav><div class="flex space-x-2"><select id=locale-select><option value=/tutorials/custom-geometry/ selected=true>English</option><option value=/ar/tutorials/custom-geometry/ >العربية</option><option value=/es/tutorials/custom-geometry/ >español</option><option value=/hi/tutorials/custom-geometry/ >हिन्दी</option><option value=/ko/tutorials/custom-geometry/ >한국어</option><option value=/pt-br/tutorials/custom-geometry/ >português (Brasil)</option><option value=/sk/tutorials/custom-geometry/ >slovenčina</option><option value=/zh/tutorials/custom-geometry/ >中文</option></select><script>document.getElementById("locale-select")?.addEventListener("change",(function(){window.location.href=this.value}))</script><div><form action=/search method=GET role=search><label for=search-term>Search</label> <input aria-label="Search through site content" class="border border-black" id=search-term name=term required type=search> <button type=submit>Search</button></form></div><div>Language: en</div><div>Accessibility</div></div><h1 class="font-bold text-lg">Creating Custom Geometry in WebGL</h1><span></span><main><h6>By Dave Pagurek, Austin Lee Slominski, Adam Ferriss</h6><p>p5.js has a number of built-in basic shapes, like <code>box()</code> and <code>sphere()</code>. It can also render complex custom geometry, both from 3D model files or code. This tutorial will walk through how to import 3D models into p5.js, as well as how to create geometry from scratch.</p><h2 id=loading-3d-models-from-file>Loading 3D models from file</h2><p>Custom geometry can be imported into p5.js using either OBJ or STL files. These files are usually generated in a 3D modeling tool like Blender, which offers much more control when constructing a 3D scene. This is done using the <code>loadModel()</code> method, which should be used within <code>preload()</code>. Then, you can use the <code>model()</code> function to draw the model, as demonstrated in the example below.</p><style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(self.Astro||(self.Astro={})).load=async t=>{await(await t())()},window.dispatchEvent(new Event("astro:load")),(()=>{var t,e=Object.defineProperty,r=(t,r,n)=>(((t,r,n)=>{r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[r]=n})(t,"symbol"!=typeof r?r+"":r,n),n);{let e={0:t=>i(t),1:t=>s(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(s(t)),5:t=>new Set(s(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},n=t=>{let[r,n]=t;return r in e?e[r](n):void 0},s=t=>t.map(n),i=t=>"object"!=typeof t||null===t?t:Object.fromEntries(Object.entries(t).map((([t,e])=>[t,n(e)])));customElements.get("astro-island")||customElements.define("astro-island",(t=class extends HTMLElement{constructor(){super(...arguments),r(this,"Component"),r(this,"hydrator"),r(this,"hydrate",(async()=>{var t;if(!this.hydrator||!this.isConnected)return;let e=null==(t=this.parentElement)?void 0:t.closest("astro-island[ssr]");if(e)return void e.addEventListener("astro:hydrate",this.hydrate,{once:!0});let r,n=this.querySelectorAll("astro-slot"),s={},o=this.querySelectorAll("template[data-astro-template]");for(let t of o){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("data-astro-template")||"default"]=t.innerHTML,t.remove())}for(let t of n){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("name")||"default"]=t.innerHTML)}try{r=this.hasAttribute("props")?i(JSON.parse(this.getAttribute("props"))):{}}catch(t){let e=this.getAttribute("component-url")||"<unknown>",r=this.getAttribute("component-export");throw r&&(e+=` (export ${r})`),console.error(`[hydrate] Error parsing props for component ${e}`,this.getAttribute("props"),t),t}await this.hydrator(this)(this.Component,r,s,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))})),r(this,"unmount",(()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))}))}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(this.hasAttribute("await-children")&&"interactive"!==document.readyState&&"complete"!==document.readyState){let t=()=>{document.removeEventListener("DOMContentLoaded",t),e.disconnect(),this.childrenConnectedCallback()},e=new MutationObserver((()=>{var e;(null==(e=this.lastChild)?void 0:e.nodeType)===Node.COMMENT_NODE&&"astro:end"===this.lastChild.nodeValue&&(this.lastChild.remove(),t())}));e.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",t)}else this.childrenConnectedCallback()}async childrenConnectedCallback(){let t=this.getAttribute("before-hydration-url");t&&await import(t),this.start()}async start(){let t=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(void 0!==Astro[e])try{await Astro[e]((async()=>{let t=this.getAttribute("renderer-url"),[e,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),t?import(t):()=>()=>{}]),n=this.getAttribute("component-export")||"default";if(n.includes(".")){this.Component=e;for(let t of n.split("."))this.Component=this.Component[t]}else this.Component=e[n];return this.hydrator=r,this.hydrate}),t,this)}catch(t){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,t)}else window.addEventListener(`astro:${e}`,(()=>this.start()),{once:!0})}attributeChangedCallback(){this.hydrate()}},r(t,"observedAttributes",["props"]),t))}})()</script><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let teapotModel;\nfunction preload() {\n  teapotModel = loadModel(&#39;/models/teapot.obj&#39;, true);\n}\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;A model of a teapot&#39;);\n}\nfunction draw(){\n  background(255);\n \n  // Click and drag to look around the shape\n  orbitControl();\n \n  // This adds color to the model according to the angle of the surface\n  normalMaterial();\n  model(teapotModel);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=19XxzJ><div class=code-placeholder></div></astro-island><p>A common issue that can come up with custom models is scaling. Depending on how the model is constructed, it might be a very different size when drawn in p5.js, or be too small to be drawn at all. The <code>loadModel()</code> method includes a <code>normalize</code> parameter that will resize the model to something that works better in p5.js.</p><p><em>Note that there is currently no support for loading materials and colors from model files. You can add color, materials, and textures manually after loading a model, which you can learn about in the</em> <a href=styling-and-appearance><em>Styling and Appearance</em></a> <em>tutorial.</em></p><div class=callout><h5>Try this!</h5><p>Try <a href=https://sketchfab.com/features/free-3d-models>finding a 3D model online</a> and integrating it into a sketch!</p></div><h2 id=creating-procedural-geometry>Creating procedural geometry</h2><p>Geometry can also be defined procedurally using code. This is a great way to create geometry that moves or is formed using your own set of rules. There are a number of methods that can be used to create 3D geometry in a way that is similar to 2D drawing. For example, functions like <code>quad()</code>, <code>triangle()</code>, <code>rect()</code>, and <code>circle()</code> each have extra parameters that make it possible to use them in 3D.</p><p>There are other functions that offer greater control of the geometry. A shape can be defined point-by-point using <code>beginShape()</code>, <code>vertex()</code>, and <code>endShape()</code>. The following example shows how these functions can be used to construct a 3D shape.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;function setup() {\n  createCanvas(216, 216, WEBGL);\n  colorMode(HSB);\n  describe(&#39;A ribbon rotating in a spiral&#39;);\n}\n\nfunction draw() {\n  background(255);\n  \n  // Click and drag to look around the shape\n  orbitControl();\n  \n  // Angle down and to the right to get a better view\n  rotateX(PI * -0.2);\n  rotateY(PI * 0.2);\n  \n  // Draw a strip of quads in a spiral formation\n  beginShape(QUAD_STRIP);\n  for (let z = -100; z &lt; 100; z += 5) {\n    fill((z + frameCount) % 360, 100, 100);\n    \n    // Rotate the end point based on how far back it is,\n    // and additionally based on the time\n    let endPoint = createVector(0, 20);\n    endPoint.rotate((z + frameCount) * 0.1);\n    \n    // In a QUAD_STRIP, each pair of vertices forms a\n    // quad with the next pair. By making each pair have\n    // a small y offset between them, we make a vertical\n    // ribbon.\n    vertex(endPoint.x, endPoint.y - 5, z);\n    vertex(endPoint.x, endPoint.y + 5, z);\n  }\n  endShape();\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=Z23AyGS><div class=code-placeholder></div></astro-island><div class=callout><h5>Try this!</h5><p>Can you create a 3D bolt of lightning using <code>beginShape(QUAD_STRIP)</code>?</p></div><h2 id=reusing-procedural-geometry>Reusing procedural geometry</h2><p>This method is great for creating custom shapes that change over time. Sometimes, you might only need a fixed shape or want an efficient way to draw a shape many times. For this, p5.js has a function called buildGeometry() to turn your custom shapes into the same format as a loaded model. If you are planning on making a particle system, this is a good tool to reach for.</p><p>It takes in a function that draws some shapes. It will then output geometry that you can draw with model() as often as you like.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let bug;\n\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;Bugs randomly moving around&#39;);\n  \n  // Record shapes and store them\n  bug = buildGeometry(() =&gt; {\n    // Head\n    push();\n    translate(-50, 0, 0);\n    sphere(70);\n    \n    // Draw symmetrical parts of the head that come\n    // in pairs by looping over each side of the head\n    for (let side of [-1, 1]) {\n      // Eye\n      push();\n      translate(-20, -60, side * 30);\n      sphere(20);\n      pop();\n\n      // Antenna\n      push();\n      translate(0, -100, side * 30);\n      rotateX(PI * -0.1 * side);\n      cylinder(5, 100);\n      pop();\n    }\n    pop();\n\n    // Body\n    push();\n    translate(50, 0, 0);\n    scale(1.5, 0.8, 1);\n    sphere(100);\n    pop();\n  });\n}\n\nfunction draw() {\n  background(255);\n  orbitControl();\n  rotateX(PI * -0.1);\n  \n  noStroke();\n  lights();\n  \n  // Draw a bunch of bugs\n  for (let i = 0; i &lt; 20; i++) {\n    push();\n    // Move each bug to a random position and rotation using noise\n    translate(\n      map(\n        noise(frameCount*0.001, i, 0), // Map this value...\n        0, 1, // ...from this range...\n        -150, 150 // ...into this range\n      ),\n      0,\n      map(\n        noise(frameCount*0.001, i, 100),  // Map this value...\n        0, 1, // ...from this range...\n        -200, 300 // ...into this range\n      )\n    );\n    rotateY(noise(frameCount*0.01, i, 200) * TWO_PI);\n    scale(0.1);\n    model(bug);\n    pop();\n  }\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=2q1wko><div class=code-placeholder></div></astro-island><div class=callout><h5>Try this!</h5><p>Try making a few snowflakes using <code>buildGeometry</code>, and then use them to create a big snowfall!</p></div><h2 id=smooth-shading>Smooth shading</h2><p>A normal is the direction that is perpendicular to the face, which helps p5.js calculate lighting across the surface.</p><p><img alt="A triangular face with an arrow pointing directly out of it representing its normal" decoding=async height=500 loading=lazy src=/_astro/face-normal.29r1NfX3_19icYS.webp width=500></p><p>As long as every vertex shared between touching faces has the same normal, then shading will look smooth. You can specify normals manually by calling <code>normal(x, y, z)</code> before each <code>vertex(x, y, z)</code>, but p5.js includes functionality to calculate these for you. The following example uses <code>geometry.calculateNormals(SMOOTH)</code> to create a warped tube with smooth lighting.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let tube;\n\nfunction setup() {\n  createCanvas(216, 216, WEBGL);\n  describe(\&quot;A rotating, warped tube\&quot;);\n  \n  tube = buildGeometry(() =&gt; {\n    let verticesPerRing = 20;\n    let rings = 20;\n    for (let ring = 0; ring &lt; rings - 1; ring++) {\n      beginShape(QUAD_STRIP);\n      for (let i = 0; i &lt;= verticesPerRing; i++) {\n        for (let ringOffset of [0, 1]) {\n          let y = map(ring + ringOffset, 0, rings, 70, -70);\n          let angle = map(i, 0, verticesPerRing, 0, TWO_PI);\n          \n          // Rotate a line 70px from the tube center according to the angle\n          let position = createVector(70, 0).rotate(angle);\n\n          // Pick a random value between 0 and 1 that we&#39;ll use to squish\n          // the tube in towards the center. The input to noise() changes\n          // based on the position of the shape to get a smoothly changing\n          // output.\n          // If you were to set radius=1 instead, you would get a perfect\n          // tube with no warping.\n          let radius = noise(\n            200 + position.x * 0.01,\n            200 + y * 0.01,\n            200 + position.y * 0.01\n          );\n\n          // Use radius to squish in towards the center of the tube\n          let squishedPosition = createVector(\n            position.x * radius,\n            y,\n            position.y * radius\n          );\n          \n          vertex(squishedPosition.x, squishedPosition.y, squishedPosition.z);\n        }\n      }\n      endShape();\n    }\n  });\n  tube.computeNormals(SMOOTH);\n}\n\nfunction draw() {\n  background(255);\n  orbitControl();\n\n  lights();\n  noStroke();\n  specularMaterial(50);\n  shininess(100);\n  rotateY(frameCount * 0.01);\n  model(tube);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=Z28bK4S><div class=code-placeholder></div></astro-island><div class=callout><h5>Try this!</h5><p>Try making a smooth, organic shape in p5. Can you create buildings in the style of <a href=https://en.wikipedia.org/wiki/Guggenheim_Museum_Bilbao#/media/File:Museo_Guggenheim,_Bilbao_(31273245344).jpg>Frank Gehry</a>, built out of smooth, wavy strips?</p></div><h2 id=advanced-geometry-techniques>Advanced geometry techniques</h2><p>Sometimes, you need even more flexibility when making shapes. For example, sometimes you want vertices to be connected irregularly into faces rather than through a grid, or you want to use custom normals or texture coordinates calculated after having generated all your vertices. The <code>p5.Geometry</code> class gives full flexibility in creating vertices, faces, texture coordinates, and normals. p5.js uses <code>p5.Geometry</code> internally for <code>loadModel()</code> and <code>buildGeometry()</code>.</p><p>In 3D, a face refers to a collection of three points that make up a surface, giving our geometry the appearance of being solid. In <code>p5.Geometry</code>, you create faces by:</p><ol><li>Putting all the points you will use into a big array in the <code>geometry.vertices</code> property, and remembering the <strong>order</strong> the points are added.</li><li>Putting sets of three indices at a time into the <code>geometry.faces</code> array. The <strong>index</strong> of a point refers to its position in the array, determined by the order in which it was added. Index 0 corresponds to the first point you added, index 1 corresponds to the second, index 2 corresponds to the third, etc.</li></ol><p><img alt="An illustration of how to create faces by referring to vertices by their positions in the array. Four vertices are created in a square in a left-to-right then top-to-bottom order. A trianlge is formed in the bottom left of the square with indices [0, 3, 2], and a triangle is formed in the top right with indices [0, 1, 3]." decoding=async height=370 loading=lazy src=/_astro/faces.C1tUZifO_1dawUB.svg width=600></p><p>The following example uses this method of creating vertices and faces to create a custom tetrahedron shape.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let tetrahedron;\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;A rotating tetrahedron&#39;);\n \n  tetrahedron = new p5.Geometry();\n \n  // Give each geometry a unique gid\n  tetrahedron.gid = &#39;tetrahedron&#39;;\n \n  // Add four points of the tetrahedron\n \n  let radius = 50;\n  // A 2D triangle:\n  tetrahedron.vertices.push(createVector(radius, 0, 0));\n  tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));\n  tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));\n  // Add a tip in the z axis:\n  tetrahedron.vertices.push(createVector(0, 0, radius));\n \n  // Create the four faces by connecting the sets of three points\n  tetrahedron.faces.push([0, 1, 2]);\n  tetrahedron.faces.push([0, 1, 3]);\n  tetrahedron.faces.push([0, 2, 3]);\n  tetrahedron.faces.push([1, 2, 3]);\n}\nfunction draw() {\n  background(200);\n  strokeWeight(2);\n  orbitControl();\n  rotateY(millis() * 0.001);\n  model(tetrahedron);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=ZqLPQP><div class=code-placeholder></div></astro-island><p>You can also push a <code>p5.Vector</code> into the <code>geometry.normals</code> array for each vertex you push into <code>geometry.vertices</code>. However, you can still call <code>geometry.computeNormals()</code> for custom <code>p5.Geometry</code> just like you can for geometry built with <code>buildGeometry()</code>.</p><div class=callout><h5>Try this!</h5><p>A tetrahedron is part of a group of shapes called <a href=https://en.wikipedia.org/wiki/Platonic_solid>Platonic solids</a>. Try generating more of them as <code>p5.Geometry</code>!</p></div><h2 id=conclusion>Conclusion</h2><p>Now, you should be able to create custom geometry, making it possible to create unique shapes, both from other tools and from code. Spend some time working with a variety of 3D modeling tools so you can find the one that works best for you. If you find bugs please raise an issue on <a href=https://github.com/processing/p5.js/ >Github</a>, or if you run into trouble, feel free to ask questions <a href=https://discord.gg/SHQ8dH25r9>on Discord</a> or the <a href=https://discourse.processing.org/ >Processing Foundation Discourse forum</a>.</p><h2 id=glossary>Glossary</h2><h4 id=procedural>Procedural</h4><p>Meaning that something is defined mathematically, instead of from stored data, like a file.</p><h4 id=model>Model</h4><p>A representation of geometry.</p><h4 id=stl>STL</h4><p>STL (most often standing for “standard tesselation language”) is a file format for 3D models. It only stores information about the geometry.</p><h4 id=obj>OBJ</h4><p>OBJ is an open file format that stores geometry data as well as some material and texture data. In p5.js, we are limited to its geometry, although an image can still be mapped to the surface using textures.</p><h4 id=vertices>Vertices</h4><p>The points of a shape that make up the corners of its faces.</p><h4 id=faces>Faces</h4><p>The solid surface that is generated between three points.</p><h4 id=normals>Normals</h4><p>The direction that is perpendicular to a face which is often needed when calculating lighting or using materials.</p><h4 id=normalization>Normalization</h4><p>Changing something so that it fits within a standard range.</p><h4 id=indices>Indices</h4><p>Positions in the array of vertices. Faces reference vertices by these positions.</p><h4 id=loadmodel><code>loadModel()</code></h4><p>A p5.js function to load a shape from an OBJ or STL file.</p><h4 id=p5geometry><code>p5.Geometry</code></h4><p>A class that p5.js uses to store shapes.</p><h4 id=model-1><code>model()</code></h4><p>A p5.js function to draw a shape to the screen.</p><h4 id=buildgeometry><code>buildGeometry()</code></h4><p>A p5.js function to record all the shapes that get drawn and save them into a new <code>p5.Geometry</code> object.</p><h4 id=computenormals><code>computeNormals()</code></h4><p>A method that can be called on <code>p5.Geometry</code> to calculate the direction coming out of each face so that they don’t need to be manually created.</p><h2>Related examples</h2><ul></ul><h2>Related references</h2><ul></ul></main><div>p5.js site footer goes here</div></body></html>