<!DOCTYPE html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_astro/_slug_.C79K3bky.css rel=stylesheet /></head><body><nav><ul><a href=/ >Home</a> <a href=/reference>Reference</a> <a href=/tutorials>Tutorials</a> <a href=/examples>Examples</a> <a href=/community>Community</a> <a href=/about>About</a> <a href=/contribute>Contribute</a></ul></nav><div class="flex space-x-2"><select id=locale-select><option value=/contribute//project_wrapups/aidannelson_gsoc_2018/ selected=true>English</option><option value=/ar/contribute//project_wrapups/aidannelson_gsoc_2018/ >العربية</option><option value=/es/contribute//project_wrapups/aidannelson_gsoc_2018/ >español</option><option value=/hi/contribute//project_wrapups/aidannelson_gsoc_2018/ >हिन्दी</option><option value=/ko/contribute//project_wrapups/aidannelson_gsoc_2018/ >한국어</option><option value=/pt-br/contribute//project_wrapups/aidannelson_gsoc_2018/ >português (Brasil)</option><option value=/sk/contribute//project_wrapups/aidannelson_gsoc_2018/ >slovenčina</option><option value=/zh/contribute//project_wrapups/aidannelson_gsoc_2018/ >中文</option></select><script>document.getElementById("locale-select")?.addEventListener("change",(function(){window.location.href=this.value}))</script><div><form action=/search method=GET role=search><label for=search-term>Search</label> <input aria-label="Search through site content" class="border border-black" id=search-term name=term required type=search> <button type=submit>Search</button></form></div><div>Language: en</div><div>Accessibility</div></div><h1 class="font-bold text-lg">Placeholder title</h1><span></span><main><h1 id=p5js-webgl-updates>p5.js WebGL Updates</h1><p>Over the course of this Google Summer of Code 2018 project for The Processing Foundation, I worked along with <a href=https://github.com/AdilRabbani>Adil Rabbani</a> and our mentors <a href=https://github.com/kjhollen>Kate Hollenbach</a> and <a href=https://github.com/mlarghydracept>Stalgia Grigg</a> to further expand and improve p5.js’ WebGL implementation. I focused specifically on helping beginner coders visualize and understand 3D space through an expanded orbitControl(), reorganization and expansion of the camera and a debugMode().</p><h2 id=contributing-to-the-library>Contributing to the Library</h2><p>Having never before contributed substantially to open-source, I began the summer by getting up to speed on p5.js’ contribution practices, the automated build process and working with git on our shared <a href=https://github.com/processing/p5.js/tree/webgl-gsoc-2018>webgl-gsoc-2018</a> branch. During this time, I worked on improving existing WebGL mode documentation <a href=https://github.com/processing/p5.js/pull/2940>here</a> and <a href=https://github.com/processing/p5.js/pull/2939>here</a>. In addition, fixing minor bugs (<a href=https://github.com/processing/p5.js/pull/2944>here</a>, <a href=https://github.com/processing/p5.js/pull/2945>here</a>, <a href=https://github.com/processing/p5.js/pull/2975>here</a> and <a href=https://github.com/processing/p5.js/pull/2976>here</a>) helped enormously to understand how the WebGL mode and broader p5.js codebases interacted with each other, with the browser and with the graphics card, as did a deep and ongoing friendship with the Chrome Debugger.</p><p>Along with this work, I found it extremely helpful to learn and use ‘vanilla’ WebGL outside of the p5.js ecosystem. Without the implementation-specific complexity of a library, I found it much easier to see how the various elements of a WebGL canvas interact. This series of <a href="https://www.youtube.com/watch?v=kB0ZVUrI4Aw">videos</a> is particularly thorough in setting up a WebGL context, writing shaders and creating a program, and implementing the various matrices necessary for a 3D scene. To develop a more high-level background on the matrix math underlying 3D graphics and an intuitive sense of how matrices are composed, I found this series of <a href="https://www.youtube.com/watch?v=kjBOesZCoqc&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">videos</a> very helpful. Among the dozens of articles I found on 3D cameras and projection, the chapters on <a href=http://learnwebgl.brown37.net/#section-7-cameras>camera control</a> and <a href=http://learnwebgl.brown37.net/#section-8-projections-and-viewports>projection</a> in ‘Learn WebGL’ were particularly helpful in developing an approach to the p5.Camera object reorganization.</p><h2 id=orbitcontrol>orbitControl()</h2><p><code>orbitControl()</code> allows a user to control the camera view of a sketch with the mouse. It is a very quick and easy way to debug code, better understand the 3D coordinate system and how other other p5.js WebGL functions (<code>rotateXYZ()</code>, <code>translate()</code>, <code>perspective()</code> and <code>ortho()</code>, for instance) manipulate objects and view within a 3D sketch. Building upon the existing <code>orbitControl()</code>, which allowed two-axis rotation of a sketch, and with the goal of implementing similar functionality to <a href="https://threejs.org/examples/?q=control#misc_controls_orbit">this</a> set of three.js controls, I went to work on adding several features: persistence (rotation would not reset after the mouse is released), maintaining Y-Up orientation, and pan and zoom control.</p><p>Adding all of this to a single function turned out to be somewhat unwieldy within the existing structure of the p5.RendererGL object, however, and helped prompt the decision to move all camera functionality into a separate p5.Camera object. This done, <code>orbitControl()</code> was rebuilt to use the p5.Camera object <a href=https://github.com/processing/p5.js/pull/3088>here</a>.</p><p><img alt="orbitControl() with persistence, panning, y-up-orientation, and zoom" src=http://www.aidanjnelson.com/files/gsoc-wpr-images/orbit-after.gif /></p><h2 id=p5camera-reorganization>p5.Camera Reorganization</h2><p>Reorganizing all camera code into a separate p5.Camera object <a href=https://github.com/processing/p5.js/pull/3080>here</a> proved useful for two reasons: internally, it further modularized the WebGL codebase, allowing expansion of the camera while simplifying the rendererGL object, and externally, it allowed users to store references to and manipulate a camera object directly. The p5.Camera has several new methods and several ‘wrapper’ methods which simplify camera control (<code>pan()</code>, <code>tilt()</code>, <code>move()</code>) and the user can now store, manipulate and switch between several p5.Camera objects using the <code>setCamera()</code> method.</p><pre class="astro-code github-dark" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> cam1 </span><span style=color:#f97583>=</span><span style=color:#b392f0> createCamera</span><span style=color:#e1e4e8>(); </span><span style=color:#6a737d>// create an instance of p5.Camera object</span></span>
<span class=line></span>
<span class=line><span style=color:#e1e4e8>cam1.</span><span style=color:#b392f0>pan</span><span style=color:#e1e4e8>(angle); </span><span style=color:#6a737d>// pans the camera by an angle</span></span>
<span class=line><span style=color:#e1e4e8>cam1.</span><span style=color:#b392f0>tilt</span><span style=color:#e1e4e8>(angle); </span><span style=color:#6a737d>// tilts the camera by an angle</span></span>
<span class=line></span>
<span class=line><span style=color:#e1e4e8>cam1.</span><span style=color:#b392f0>move</span><span style=color:#e1e4e8>(x, y, z); </span><span style=color:#6a737d>// moves along the camera&#39;s local axes</span></span>
<span class=line><span style=color:#e1e4e8>cam1.</span><span style=color:#b392f0>setPosition</span><span style=color:#e1e4e8>(x, y, z); </span><span style=color:#6a737d>// sets the camera&#39;s position in world-space</span></span>
<span class=line></span>
<span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> cam2 </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> cam1.</span><span style=color:#b392f0>copy</span><span style=color:#e1e4e8>(); </span><span style=color:#6a737d>// create a copy of the camera</span></span>
<span class=line></span>
<span class=line><span style=color:#b392f0>setCamera</span><span style=color:#e1e4e8>(cam2); </span><span style=color:#6a737d>// switch between multiple p5.Camera instances</span></span></code></pre><h4 id=unit-tests>Unit Tests</h4><p>This reorganization also required adding p5.Camera object unit tests to the library’s mocha/chai automated testing framework. Unit testing was a wholly new subject to me, and the variety of testing approaches touted online (and their various acronyms: TDD, BDD, etc.) was somewhat overwhelming. My mentor Kate was extremely helpful in guiding me through this process, as was a close reading of the existing p5.js unit tests. Unit tests can be found <a href=https://github.com/processing/p5.js/pull/3083>here</a>.</p><h2 id=debugmode>debugMode()</h2><p>Because human depth perception is based in numerous visual and contextual clues often absent from 3D sketches — especially simple sketches without lighting — it can be challenging for a beginning coder to visualize and understand the 3D coordinate system in a WebGL mode sketch. For my final project of the summer, I began work on a <code>debugMode()</code> function to help visualize depth and camera orientation in a 3D sketch. This function allowed a user to add a gridded ‘ground’ plane and axes icon to their sketch with a single function call. These visual guides will, along with the use of <code>orbitControl()</code> make depth and orientation immediately apparent within a sketch. Code for this can be found <a href=https://github.com/processing/p5.js/pull/3103>here</a>.</p><table><thead><tr><th style=text-align:center><img alt="Are we moving or is the box moving?  Which way is up?" src=http://www.aidanjnelson.com/files/gsoc-wpr-images/noDebugMode.gif /></th><th style=text-align:center><img alt="Easier to identify orientation and movement with debugMode()" src=http://www.aidanjnelson.com/files/gsoc-wpr-images/debugMode.gif /></th></tr></thead><tbody><tr><td style=text-align:center>Are we moving or is the box moving? Which way is up?</td><td style=text-align:center>Easier to identify orientation and movement with debugMode()</td></tr></tbody></table><h2 id=summary>Summary</h2><p>A full list of my contributions to the WebGL branch can be found <a href="https://github.com/processing/p5.js/commits/webgl-gsoc-2018?author=aidannelson">here</a> and my merged pull requests can be found <a href="https://github.com/processing/p5.js/pulls?q=is%3Apr+is%3Amerged+author%3AAidanNelson">here</a>.</p><p>Working on this project for p5.js has been an incredible learning experience and a joy. I am extremely grateful to the Processing community and especially to my mentor, Kate Hollenbach, for a summer’s worth of guidance, debugging, git tutorials, WebGL articles and support. Thank you!</p></main><div>p5.js site footer goes here</div></body></html>