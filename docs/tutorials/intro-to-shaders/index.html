<!DOCTYPE html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_astro/_slug_.C79K3bky.css rel=stylesheet /></head><body><nav><ul><a href=/ >Home</a> <a href=/reference>Reference</a> <a href=/tutorials>Tutorials</a> <a href=/examples>Examples</a> <a href=/community>Community</a> <a href=/about>About</a> <a href=/contribute>Contribute</a></ul></nav><div class="flex space-x-2"><select id=locale-select><option value=/tutorials/intro-to-shaders/ selected=true>English</option><option value=/ar/tutorials/intro-to-shaders/ >العربية</option><option value=/es/tutorials/intro-to-shaders/ >español</option><option value=/hi/tutorials/intro-to-shaders/ >हिन्दी</option><option value=/ko/tutorials/intro-to-shaders/ >한국어</option><option value=/pt-br/tutorials/intro-to-shaders/ >português (Brasil)</option><option value=/sk/tutorials/intro-to-shaders/ >slovenčina</option><option value=/zh/tutorials/intro-to-shaders/ >中文</option></select><script>document.getElementById("locale-select")?.addEventListener("change",(function(){window.location.href=this.value}))</script><div><form action=/search method=GET role=search><label for=search-term>Search</label> <input aria-label="Search through site content" class="border border-black" id=search-term name=term required type=search> <button type=submit>Search</button></form></div><div>Language: en</div><div>Accessibility</div></div><h1 class="font-bold text-lg">Introduction to Shaders</h1><span></span><main><h6>By Dave Pagurek, Austin Lee Slominski, Adam Ferriss</h6><p>Modern computers come with a special piece of hardware called the Graphics Processing Unit, or GPU. Shaders are special programs that run on it and can do incredible things. They take advantage of the GPU to process many pixels at once in parallel, making them fast and particularly well suited for certain tasks in computer graphics, like generating noise, applying filters like blur, or shading polygons.</p><p>Shader programming can feel daunting at first, requiring a different approach than the 2D drawing of p5.js. This tutorial will outline the basics of shader programming and point you towards other resources.</p><h2 id=setup>Setup</h2><p>The way to program the GPU in your browser is by using an API called <a href=https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API>WebGL</a>. p5.js is a great tool for working with shaders because it handles a lot of the boilerplate WebGL setup, letting you focus on the shader code itself. Before we can get started with shaders we have to set up our p5.js canvas so that it uses WebGL mode. We do this by adding the <code>WEBGL</code> constant as the third parameter in <code>createCanvas()</code>.</p><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>...</span></span>
<span class=line></span>
<span class=line><span style=color:#f97583>function</span><span style=color:#b392f0> setup</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#b392f0>  createCanvas</span><span style=color:#e1e4e8>(</span><span style=color:#79b8ff>200</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>200</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>WEBGL</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line></span>
<span class=line><span style=color:#f97583>...</span></span></code></pre><p>A shader program consists of two parts, a <strong>vertex shader</strong> and a <strong>fragment shader</strong>. The vertex shader is a program that runs once for each vertex in a piece of geometry and determines where it gets drawn on the screen. The fragment shader is a program that runs once for every pixel in that geometry and determines its color.</p><table><tr><td><p><img alt="A red sphere" decoding=async height=400 loading=lazy src=/_astro/sphere.CTbNDyo9_Z2vspJu.webp width=400></p></td><td><p><img alt="A red sphere that wobbles and distorts over time" decoding=async height=400 loading=lazy src=/_astro/vertshader.BXsGrBw-_Za3ejq.webp width=400></p></td><td><p><img alt="A silhouette of a wobbly sphere, colored in with red and blue stripes" decoding=async height=400 loading=lazy src=/_astro/fragshader.DLkWiDe__Zu7RSk.webp width=400></p></td></tr><tr><td><p><em>Original shape</em></p></td><td><p><em>A custom vertex shader can adjust the positions of vertices within a shape</em></p></td><td><p><em>A custom fragment shader can adjust the colors inside a shape</em></p></td></tr></table><p>Each of these live in separate files and are loaded into p5.js using the <code>loadShader()</code> function. Once a shader is loaded, it can be used within <code>setup()</code> or <code>draw()</code>. The following example will show how to set up a basic shader within p5.js:</p><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> myShader;</span></span>
<span class=line><span style=color:#f97583>function</span><span style=color:#b392f0> preload</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>  // load each shader file (don&#39;t worry, we will come back to these!)</span></span>
<span class=line><span style=color:#e1e4e8>  myShader </span><span style=color:#f97583>=</span><span style=color:#b392f0> loadShader</span><span style=color:#e1e4e8>(</span><span style=color:#9ecbff>&#39;shader.vert&#39;</span><span style=color:#e1e4e8>, </span><span style=color:#9ecbff>&#39;shader.frag&#39;</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line><span style=color:#f97583>function</span><span style=color:#b392f0> setup</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>  // the canvas has to be created with WEBGL mode</span></span>
<span class=line><span style=color:#b392f0>  createCanvas</span><span style=color:#e1e4e8>(windowWidth, windowHeight, </span><span style=color:#79b8ff>WEBGL</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line><span style=color:#f97583>function</span><span style=color:#b392f0> draw</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>  // shader() sets the active shader, which will be applied to what is drawn next</span></span>
<span class=line><span style=color:#b392f0>  shader</span><span style=color:#e1e4e8>(myShader);</span></span>
<span class=line><span style=color:#6a737d>  // apply the shader to a rectangle taking up the full canvas</span></span>
<span class=line><span style=color:#b392f0>  plane</span><span style=color:#e1e4e8>(width, height);</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre><p>There is also an additional function called <code>createShader()</code>, which can be used to load shaders directly from strings defined in your sketch. </p><h2 id=writing-shaders>Writing Shaders</h2><p>Now, we’ll look at what goes into the vertex and fragment shader files we referenced in <code>loadShader()</code>.</p><h3 id=shading-language-glsl>Shading Language (GLSL)</h3><p>Shader files are written in the Graphics Library Shading Language, or GLSL (based on OpenGL 2.0 and GLSL ES 1.00), and have a very different syntax and structure than we are familiar with. GLSL has a syntax that resembles C, which means it comes with a handful of concepts that aren’t present in JavaScript.</p><p>For one, the shading language is much more strict about types. Each variable you create has to be labeled with the kind of data it is storing. Here is a list of some of the common types:</p><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>vec2</span><span style=color:#e1e4e8>(x,y)</span><span style=color:#6a737d>     // a vector of two floats</span></span>
<span class=line><span style=color:#f97583>vec3</span><span style=color:#e1e4e8>(x,y,z)</span><span style=color:#6a737d>   // a vector of three floats (could also be r,g,b)</span></span>
<span class=line><span style=color:#f97583>vec4</span><span style=color:#e1e4e8>(x,y,z,w)</span><span style=color:#6a737d> // a vector of four floats (could also be r,g,b,a)</span></span>
<span class=line><span style=color:#f97583>float</span><span style=color:#6a737d>         // a number with decimal points</span></span>
<span class=line><span style=color:#f97583>int</span><span style=color:#6a737d>           // a whole number without decimal points</span></span>
<span class=line><span style=color:#f97583>sampler2D</span><span style=color:#6a737d>     // a reference to a texture</span></span>
<span class=line><span style=color:#f97583>mat2</span><span style=color:#6a737d>          // a 2x2 matrix</span></span>
<span class=line><span style=color:#f97583>mat3</span><span style=color:#6a737d>          // a 3x3 matrix</span></span>
<span class=line><span style=color:#f97583>mat4</span><span style=color:#6a737d>          // a 4x4 matrix</span></span>
<span class=line><span style=color:#f97583>bool</span><span style=color:#6a737d>          // true or false</span></span></code></pre><p>In general shading languages are much more strict than JavaScript. A missing semicolon is not allowed and will result in an error message. You can’t use different types of numbers, like floats or integers interchangeably. It also will complain about <code>float</code>s that aren’t defined with a decimal place in them, so you will find yourself writing numbers like <code>0.0</code> or <code>1.0</code> often.</p><p>Here are some things that are different in GLSL:</p><table><tr><td></td><th><p>Javascript</p></th><th><p>GLSL</p></th></tr><tr><td><p>All variables need types.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> a </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 1</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0.5</span><span style=color:#e1e4e8>;</span></span></code></pre></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>int</span><span style=color:#e1e4e8> a </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 1</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>float</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0.5</span><span style=color:#e1e4e8>;</span></span></code></pre></td></tr><tr><td><p>Functions must declare the types of their parameters, and their return value.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>function</span><span style=color:#b392f0> isBetween</span><span style=color:#e1e4e8>(</span><span style=color:#ffab70>val</span><span style=color:#e1e4e8>, </span><span style=color:#ffab70>start</span><span style=color:#e1e4e8>, </span><span style=color:#ffab70>end</span><span style=color:#e1e4e8>) {</span></span>
<span class=line><span style=color:#f97583>  return</span><span style=color:#e1e4e8> val </span><span style=color:#f97583>&gt;=</span><span style=color:#e1e4e8> start </span><span style=color:#f97583>&amp;&amp;</span><span style=color:#e1e4e8> val </span><span style=color:#f97583>&lt;=</span><span style=color:#e1e4e8> end;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>bool</span><span style=color:#b392f0> isBetween</span><span style=color:#e1e4e8>(</span><span style=color:#f97583>float</span><span style=color:#ffab70> val</span><span style=color:#e1e4e8>, </span><span style=color:#f97583>float</span><span style=color:#ffab70> start</span><span style=color:#e1e4e8>, </span><span style=color:#f97583>float</span><span style=color:#ffab70> end</span><span style=color:#e1e4e8>) {</span></span>
<span class=line><span style=color:#f97583>  return</span><span style=color:#e1e4e8> val </span><span style=color:#f97583>&gt;=</span><span style=color:#e1e4e8> start </span><span style=color:#f97583>&amp;&amp;</span><span style=color:#e1e4e8> val </span><span style=color:#f97583>&lt;=</span><span style=color:#e1e4e8> end;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td></tr><tr><td><p>You have to convert between integers and floats yourself.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> a </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 1</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0.5</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> c </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>+</span><span style=color:#79b8ff> 2</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> d </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> a </span><span style=color:#f97583>+</span><span style=color:#e1e4e8> b;</span></span></code></pre></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>int</span><span style=color:#e1e4e8> a </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 1</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>float</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0.5</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>float</span><span style=color:#e1e4e8> c </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> b </span><span style=color:#f97583>+</span><span style=color:#79b8ff> 2.0</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>float</span><span style=color:#e1e4e8> d </span><span style=color:#f97583>=</span><span style=color:#f97583> float</span><span style=color:#e1e4e8>(a) </span><span style=color:#f97583>+</span><span style=color:#e1e4e8> b;</span></span></code></pre></td></tr><tr><td><p>Loops in GLSL have to stop at a constant value. If you want to end conditionally, you can <code>break</code> out of the loop.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>let</span><span style=color:#e1e4e8> maxVal </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 10</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>if</span><span style=color:#e1e4e8> (something) {</span></span>
<span class=line><span style=color:#e1e4e8>  maxVal </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 20</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line><span style=color:#f97583>for</span><span style=color:#e1e4e8> (</span><span style=color:#f97583>let</span><span style=color:#e1e4e8> i </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0</span><span style=color:#e1e4e8>; i </span><span style=color:#f97583>&lt;</span><span style=color:#e1e4e8> maxVal; i</span><span style=color:#f97583>++</span><span style=color:#e1e4e8>) {</span></span>
<span class=line><span style=color:#6a737d>  // do something</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>int</span><span style=color:#e1e4e8> maxVal </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 10</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>if</span><span style=color:#e1e4e8> (something) {</span></span>
<span class=line><span style=color:#e1e4e8>  maxVal </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 20</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line><span style=color:#f97583>for</span><span style=color:#e1e4e8> (let i </span><span style=color:#f97583>=</span><span style=color:#79b8ff> 0</span><span style=color:#e1e4e8>; i </span><span style=color:#f97583>&lt;</span><span style=color:#79b8ff> 20</span><span style=color:#e1e4e8>; i</span><span style=color:#f97583>++</span><span style=color:#e1e4e8>) {</span></span>
<span class=line><span style=color:#f97583>  if</span><span style=color:#e1e4e8> (i </span><span style=color:#f97583>==</span><span style=color:#e1e4e8> maxVal) {</span></span>
<span class=line><span style=color:#f97583>    break</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#e1e4e8>  }</span></span>
<span class=line><span style=color:#6a737d>  // do something</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td></tr></table><p>While there are many restrictions, in some ways, GLSL can be nicer to work with! When using vectors, GLSL includes a number of helpful shortcuts:</p><table><tr><td><p>If you have a <code>vec4</code>, you can refer to its data like it is a color or a coordinate. Both are equivalent, so you can use whichever makes your code easier to read.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#6a737d>//Each pair is equivalent:</span></span>
<span class=line><span style=color:#e1e4e8>myVec.x</span></span>
<span class=line><span style=color:#e1e4e8>myVec.r</span></span>
<span class=line><span style=color:#e1e4e8>myVec.y</span></span>
<span class=line><span style=color:#e1e4e8>myVec.g</span></span>
<span class=line><span style=color:#e1e4e8>myVec.z</span></span>
<span class=line><span style=color:#e1e4e8>myVec.b</span></span>
<span class=line><span style=color:#e1e4e8>myVec.w</span></span>
<span class=line><span style=color:#e1e4e8>myVec.a</span></span></code></pre></td></tr><tr><td><p>If you want to create a vector where all of its values are the same, you don’t need to specify the same value repeatedly, just once will do.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#6a737d>// These are equivalent</span></span>
<span class=line><span style=color:#e1e4e8>myVec </span><span style=color:#f97583>=</span><span style=color:#f97583> vec3</span><span style=color:#e1e4e8>(</span><span style=color:#79b8ff>0.5</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>0.5</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>0.5</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>myVec </span><span style=color:#f97583>=</span><span style=color:#f97583> vec3</span><span style=color:#e1e4e8>(</span><span style=color:#79b8ff>0.5</span><span style=color:#e1e4e8>);</span></span></code></pre></td></tr><tr><td><p>You can get smaller vectors out of a larger vector by using something called “swizzling,” where you chain multiple property values together after a <code>.</code> in the order you want them in the new vector.</p></td><td><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#f97583>vec4</span><span style=color:#e1e4e8> bigVec </span><span style=color:#f97583>=</span><span style=color:#f97583> vec4</span><span style=color:#e1e4e8>(</span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>2.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>3.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>4.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#6a737d>// Equivalent to vec2(bigVec.z, bigVec.y)</span></span>
<span class=line><span style=color:#f97583>vec2</span><span style=color:#e1e4e8> smallVec </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> bigVec.zy;</span></span></code></pre></td></tr></table><h3 id=vertex-shaders>Vertex Shaders</h3><p>Here’s a simple vertex shader that applies the transformations and camera perspective supplied by p5.js:</p><table class=h-1><tbody><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>precision highp </span><span style=color:#f97583>float</span><span style=color:#e1e4e8>;</span></span></code></pre></td><td><p>The shader starts with a <code>precision</code> line. It can either be <code>lowp</code>, <code>mediump</code>, or <code>highp</code>. Using the highest quality is a good place to start to ensure your shaders look the same everywhere. On desktops and laptops, your GPU will likely use the highest quality regardless of what you write. On phones, using a lower quality might be faster, but it may make your shaders render differently.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec3</span><span style=color:#e1e4e8> aPosition;</span></span></code></pre></td><td><p>The <em>attributes</em> of the shader contain values that change per vertex, which p5.js uses to share information like the position of each vertex. The attribute in this shader is a <code>vec3</code>, meaning it contains a value for x, y, and z. Attributes are special variable types that are only used in the vertex shader and are typically provided by p5.js. When you use p5.js methods like <code>rect()</code> or <code>vertex()</code>, p5.js passes the vertex information to the shader for you automatically.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#6a737d>// The transform of the object being drawn</span></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uModelViewMatrix;</span></span>
<span class=line><span style=color:#6a737d>// Transforms 3D coordinates to 2D screen coordinates</span></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uProjectionMatrix;</span></span></code></pre></td><td><p>The <em>uniforms</em> of a shader are values that are constants for the whole shape being drawn. Each one in this shader happens to be a <code>mat4</code>, which is a type often used to represent transformations like translations, scales, and rotations. Multiplying a point by a <code>mat4</code> applies the transformation it represents to the point. The ones in this shader get provided automatically by p5.js, but we’ll see later how you can provide your own custom uniforms. Note that the order of multiplication with matrices matters. In most cases you will write the matrix first and the value being multiplied by it second.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>void</span><span style=color:#b392f0> main</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>&nbsp; // Apply the camera transform</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; vec4 viewModelPosition </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uModelViewMatrix </span><span style=color:#f97583>*</span><span style=color:#b392f0> vec4</span><span style=color:#e1e4e8>(aPosition, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#6a737d>&nbsp; // Tell WebGL where the vertex goes</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; gl_Position </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uProjectionMatrix </span><span style=color:#f97583>*</span><span style=color:#e1e4e8> viewModelPosition;&nbsp; </span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td><td><p>All vertex shaders require a function, <code>main()</code>, within which we position our vertices by assigning a value to <code>gl_Position</code>. This value is in <em>clip space</em>, where x, y, and z values go from -1 to 1 as they go from one side to the other. Multiplying a 3D point by <code>uProjectionMatrix</code> does this conversion for us using p5.js’s camera settings. Before we do that, this shader also multiplies by <code>uModelViewMatrix</code> to apply the accumulated transformations that were set before drawing the shape.</p></td></tr></tbody></table><p>Don’t worry if this doesn’t make a ton of sense yet. The vertex shader plays an important role but it is often just responsible for making sure what we create in our fragment shader displays properly on the geometry. You’ll probably reuse the same vertex shaders in many of your projects. Below is a standard vertex shader you can use that also handles information like per-vertex colors and texture coordinates.</p><pre class="github-dark astro-code" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#e1e4e8>precision highp </span><span style=color:#f97583>float</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec3</span><span style=color:#e1e4e8> aPosition;</span></span>
<span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec2</span><span style=color:#e1e4e8> aTexCoord;</span></span>
<span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec4</span><span style=color:#e1e4e8> aVertexColor;</span></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uModelViewMatrix;</span></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uProjectionMatrix;</span></span>
<span class=line><span style=color:#f97583>varying</span><span style=color:#f97583> vec2</span><span style=color:#e1e4e8> vTexCoord;</span></span>
<span class=line><span style=color:#f97583>varying</span><span style=color:#f97583> vec4</span><span style=color:#e1e4e8> vVertexColor;</span></span>
<span class=line><span style=color:#f97583>void</span><span style=color:#b392f0> main</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>  // Apply the camera transform</span></span>
<span class=line><span style=color:#e1e4e8>  vec4 viewModelPosition </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uModelViewMatrix </span><span style=color:#f97583>*</span><span style=color:#b392f0> vec4</span><span style=color:#e1e4e8>(aPosition, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#6a737d>  // Tell WebGL where the vertex goes</span></span>
<span class=line><span style=color:#e1e4e8>  gl_Position </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uProjectionMatrix </span><span style=color:#f97583>*</span><span style=color:#e1e4e8> viewModelPosition;  </span></span>
<span class=line><span style=color:#6a737d>  // Pass along data to the fragment shader</span></span>
<span class=line><span style=color:#e1e4e8>  vTexCoord </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> aTexCoord;</span></span>
<span class=line><span style=color:#e1e4e8>  vVertexColor </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> aVertexColor;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre><h3 id=fragment-shaders>Fragment Shaders</h3><p>The fragment shader is responsible for the color output of our shader and is where we will do a lot of our shader programming. Here is a very simple fragment shader that will just display the color red:</p><table class=h-1><tbody><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>precision highp </span><span style=color:#f97583>float</span><span style=color:#e1e4e8>;</span></span></code></pre></td><td><p>The fragment shader begins again with a line specifying the float <code>precision</code>. This should match the <code>precision</code> in your vertex shader.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>void</span><span style=color:#b392f0> main</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; vec4 myColor </span><span style=color:#f97583>=</span><span style=color:#b392f0> vec4</span><span style=color:#e1e4e8>(</span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>0.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>0.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; gl_FragColor </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> myColor;</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td><td><p>Similar to the vertex shader, our fragment shader also requires a <code>main()</code> function, but instead of setting <code>gl_Position</code>, we will assign a color to a special variable defined by GLSL called <code>gl_FragColor</code>.</p><p>The variable, <code>myColor</code>, is defined as a <code>vec4</code>, meaning it stores four values. Since we are dealing with color, those four values are red, green, blue, and alpha. Shaders don’t use 0-255 for colors like our p5.js sketches do by default. Instead, they use values between 0.0 and 1.0.</p></td></tr></tbody></table><p>Now that we have a vertex shader and a fragment shader, these can be saved to separate files (<code>shader.vert</code> and <code>shader.frag</code>, respectively) and loaded into our sketch using <code>loadShader()</code>.</p><h2 id=uniforms-passing-data-from-sketch-to-shader>Uniforms: Passing data from sketch to shader</h2><p>A simple shader like this can be useful by itself, but there are times when it’s necessary to communicate variables from the p5.js sketch to a shader. This is when uniforms come in. Uniforms are a type of variable that can be sent from a sketch to a shader. These make it possible to have much more control over a shader from JavaScript.</p><p>Uniforms are defined at the top of the file, outside of <code>main()</code>. You can access them in both your vertex and your fragment shader. In the example below, the value returned by the p5.js method <code>millis()</code> is passed to a ‘time’ uniform to introduce motion in the vertex shader.</p><style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(self.Astro||(self.Astro={})).load=async t=>{await(await t())()},window.dispatchEvent(new Event("astro:load")),(()=>{var t,e=Object.defineProperty,r=(t,r,n)=>(((t,r,n)=>{r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[r]=n})(t,"symbol"!=typeof r?r+"":r,n),n);{let e={0:t=>i(t),1:t=>s(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(s(t)),5:t=>new Set(s(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},n=t=>{let[r,n]=t;return r in e?e[r](n):void 0},s=t=>t.map(n),i=t=>"object"!=typeof t||null===t?t:Object.fromEntries(Object.entries(t).map((([t,e])=>[t,n(e)])));customElements.get("astro-island")||customElements.define("astro-island",(t=class extends HTMLElement{constructor(){super(...arguments),r(this,"Component"),r(this,"hydrator"),r(this,"hydrate",(async()=>{var t;if(!this.hydrator||!this.isConnected)return;let e=null==(t=this.parentElement)?void 0:t.closest("astro-island[ssr]");if(e)return void e.addEventListener("astro:hydrate",this.hydrate,{once:!0});let r,n=this.querySelectorAll("astro-slot"),s={},o=this.querySelectorAll("template[data-astro-template]");for(let t of o){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("data-astro-template")||"default"]=t.innerHTML,t.remove())}for(let t of n){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("name")||"default"]=t.innerHTML)}try{r=this.hasAttribute("props")?i(JSON.parse(this.getAttribute("props"))):{}}catch(t){let e=this.getAttribute("component-url")||"<unknown>",r=this.getAttribute("component-export");throw r&&(e+=` (export ${r})`),console.error(`[hydrate] Error parsing props for component ${e}`,this.getAttribute("props"),t),t}await this.hydrator(this)(this.Component,r,s,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))})),r(this,"unmount",(()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))}))}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(this.hasAttribute("await-children")&&"interactive"!==document.readyState&&"complete"!==document.readyState){let t=()=>{document.removeEventListener("DOMContentLoaded",t),e.disconnect(),this.childrenConnectedCallback()},e=new MutationObserver((()=>{var e;(null==(e=this.lastChild)?void 0:e.nodeType)===Node.COMMENT_NODE&&"astro:end"===this.lastChild.nodeValue&&(this.lastChild.remove(),t())}));e.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",t)}else this.childrenConnectedCallback()}async childrenConnectedCallback(){let t=this.getAttribute("before-hydration-url");t&&await import(t),this.start()}async start(){let t=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(void 0!==Astro[e])try{await Astro[e]((async()=>{let t=this.getAttribute("renderer-url"),[e,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),t?import(t):()=>()=>{}]),n=this.getAttribute("component-export")||"default";if(n.includes(".")){this.Component=e;for(let t of n.split("."))this.Component=this.Component[t]}else this.Component=e[n];return this.hydrator=r,this.hydrate}),t,this)}catch(t){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,t)}else window.addEventListener(`astro:${e}`,(()=>this.start()),{once:!0})}attributeChangedCallback(){this.hydrate()}},r(t,"observedAttributes",["props"]),t))}})()</script><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let myShader;\n\n// Our vertex shader source as a string\nlet vert = `\nprecision highp float;\n\nattribute vec3 aPosition;\n\n// The transform of the object being drawn\nuniform mat4 uModelViewMatrix;\n\n// Transforms 3D coordinates to 2D screen coordinates\nuniform mat4 uProjectionMatrix;\n\n// A custom uniform with the time in milliseconds\nuniform float time;\n\nvoid main() {\n  // Apply the camera transform\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Use the time to adjust the position of the vertices\n  viewModelPosition.x += 10.0 * sin(time * 0.01 + viewModelPosition.y * 0.1);\n\n  // Tell WebGL where the vertex goes\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n}\n`;\n\nlet frag = `\nprecision highp float;\n\nvoid main() {\n  vec4 myColor = vec4(1.0, 0.0, 0.0, 1.0);\n  gl_FragColor = myColor;\n}\n`\n\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  myShader = createShader(vert, frag);\n}\n\nfunction draw() {\n  background(255);\n  noStroke();\n  \n  // Use our custom shader\n  shader(myShader);\n  \n  // Pass the time from p5 to the shader\n  myShader.setUniform(&#39;time&#39;, millis());\n  \n  // Draw a shape using the shader\n  circle(0, 0, 100);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=Zkys7n><div class=code-placeholder></div></astro-island><p>It also works in the fragment shader. In the following example, we create a color uniform, <code>myColor</code>, that will allow us to change the color from the JavaScript part of our sketch. Just remember that in shaders, color channel values go from 0-1 instead of 0-255.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let myShader;\n\n// Our vertex shader source as a string\nlet vert = `\nprecision highp float;\n\nattribute vec3 aPosition;\n\n// The transform of the object being drawn\nuniform mat4 uModelViewMatrix;\n\n// Transforms 3D coordinates to 2D screen coordinates\nuniform mat4 uProjectionMatrix;\n\nvoid main() {\n  // Apply the camera transform\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Tell WebGL where the vertex goes\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n}\n`;\n\nlet frag = `\nprecision highp float;\n\n// A custom uniform to control the color\nuniform vec4 myColor;\n\nvoid main() {\n  gl_FragColor = myColor;\n}\n`\n\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  myShader = createShader(vert, frag);\n}\n\nfunction draw() {\n  background(255);\n  noStroke();\n  \n  // Use our custom shader\n  shader(myShader);\n  \n  // Create a color using the mouse&#39;s x position as red and\n  // its y position as blue, and pass it into the shader\n  myShader.setUniform(&#39;myColor&#39;, [\n    map(mouseX, 0, width, 0, 1, true), // Red\n    map(mouseY, 0, width, 0, 1, true), // Green\n    0, // Blue\n    1 // Alpha\n  ]);\n  \n  // Draw a shape using the shader\n  circle(0, 0, 100);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=6LlJK><div class=code-placeholder></div></astro-island><p>You can see the complete list of uniforms that p5.js provides for you in the <a href=https://github.com/processing/p5.js/blob/main/contributor_docs/webgl_mode_architecture.md>p5.js WebGL Mode Architecture</a> document.</p><h2 id=varyings-passing-data-from-vertex-to-fragment-shader>Varyings: Passing data from vertex to fragment shader</h2><p><em>Varying</em> variables share data between the vertex shader and the fragment shader. This makes it possible to use position or other geometry data within our fragment shaders.</p><p>For example, you may want to use a shape’s texture coordinates in the fragment shader. These come in the form of a <code>vec2</code>, where coordinates go between 0 and 1. This initially comes in an <code>attribute</code> from p5.js, and those are only accessible in the vertex shader. Let’s look at what our standard vertex shader does to pass that to fragment shaders:</p><table class=h-1><tbody><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>precision highp </span><span style=color:#f97583>float</span><span style=color:#e1e4e8>;</span></span>
<span class=line></span>
<span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec3</span><span style=color:#e1e4e8> aPosition;</span></span></code></pre></td><td></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec2</span><span style=color:#e1e4e8> aTexCoord;</span></span></code></pre></td><td><p>The texture coordinates initially come in the form of an <code>attribute</code> called <code>aTexCoord</code>. This is automatically filled in by p5.js.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>attribute</span><span style=color:#f97583> vec4</span><span style=color:#e1e4e8> aVertexColor;</span></span>
<span class=line></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uModelViewMatrix;</span></span>
<span class=line><span style=color:#f97583>uniform</span><span style=color:#f97583> mat4</span><span style=color:#e1e4e8> uProjectionMatrix;</span></span>
<span class=line></span></code></pre></td><td></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>varying</span><span style=color:#f97583> vec2</span><span style=color:#e1e4e8> vTexCoord;</span></span></code></pre></td><td><p>Here, we declare a <code>varying</code> variable. Any varying you declare in a vertex shader, you can again declare in the fragment shader, where you can then access the value assigned to it by the vertex shader.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#f97583>varying</span><span style=color:#f97583> vec4</span><span style=color:#e1e4e8> vVertexColor;</span></span>
<span class=line><span style=color:#f97583>void</span><span style=color:#b392f0> main</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>&nbsp; // Apply the camera transform</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; vec4 viewModelPosition </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uModelViewMatrix </span><span style=color:#f97583>*</span><span style=color:#b392f0> vec4</span><span style=color:#e1e4e8>(aPosition, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#6a737d>&nbsp; // Tell WebGL where the vertex goes</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; gl_Position </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> uProjectionMatrix </span><span style=color:#f97583>*</span><span style=color:#e1e4e8> viewModelPosition;</span></span></code></pre></td><td></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>&nbsp; vVertexColor </span><span style=color:#f97583>=</span><span style=color:#e1e4e8> aVertexColor;</span></span></code></pre></td><td><p>By assigning the <em>attribute’s</em> value to the <em>varying</em> variable, we are copying the data to a spot where the fragment shader can read it.</p></td></tr><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>}</span></span>
<span class=line></span></code></pre></td><td></td></tr></tbody></table><p>Since we defined a <code>varying</code> called <code>vTexCoord</code> in the vertex shader, we can now use it in the fragment shader as well. Here is a simple fragment shader that maps the x value to the red channel and the y value to the blue channel. Note that while <code>vTexCoord</code> is defined <em>per vertex</em> in the vertex shader, its value is defined <em>per pixel</em> in the fragment shader. To get the per-pixel value, WebGL smoothly interpolates between the per-vertex values on each face.</p><table class=h-1><tbody><tr class="[&>*:not(:first-child)]:max-w-xl [&>*:not(:first-child)]:py-2 [&>*]:align-top [&>*]:m-0"><td class=align-top style=height:100%;margin:0><pre class="github-dark shiki" style=background-color:#24292e;color:#e1e4e8;height:100% tabindex=0><code><span class=line><span style=color:#e1e4e8>precision highp </span><span style=color:#f97583>float</span><span style=color:#e1e4e8>;</span></span>
<span class=line><span style=color:#f97583>varying</span><span style=color:#f97583> vec2</span><span style=color:#e1e4e8> vTexCoord;</span></span>
<span class=line><span style=color:#f97583>void</span><span style=color:#b392f0> main</span><span style=color:#e1e4e8>() {</span></span>
<span class=line><span style=color:#6a737d>&nbsp; // Assign the coordinates to the color output of the shader</span></span>
<span class=line><span style=color:#e1e4e8>&nbsp; gl_FragColor </span><span style=color:#f97583>=</span><span style=color:#b392f0> vec4</span><span style=color:#e1e4e8>(vTexCoord.x, vTexCoord.y, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>, </span><span style=color:#79b8ff>1.0</span><span style=color:#e1e4e8>);</span></span>
<span class=line><span style=color:#e1e4e8>}</span></span></code></pre></td><td><p>The result of using this shader on a <code>plane(width, height)</code>:</p><img alt="A rectangular gradient with black in the top left corner, magenta in the top right, white and the bottom right, and cyan in the bottom left." decoding=async height=100 loading=lazy src=/_astro/uv_example.jUVJgM5X_x5h4k.webp width=100></td></tr></tbody></table><h2 id=filter-shaders>Filter Shaders</h2><p>In p5.js, a filter is something that looks at all the pixels on the canvas and then replaces them with something else. There are many built-in filters that do things like invert the colors of the canvas, or apply a blur to the canvas contents. You can make your own filter by writing a fragment shader for it.</p><p>Filter shaders only need a fragment shader. Vertex shaders are primarily responsible for positioning shapes, and filters always apply to the whole canvas, so p5.js provides a default vertex shader for you. Rather than using <code>loadShader</code>, you use <code>createFilterShader(src)</code>, passing in a string with your shader source code.</p><p>There are a number of <code>uniform</code>s that will be available to you in a filter shader, and you can read about all of them <a href=https://p5js.org/reference/#/p5/createFilterShader>in the <code>createFilterShader</code> documentation.</a> There are two main ones to know about to get started:</p><ul><li><code>uniform sampler2D tex0</code> is a texture containing the contents of the canvas.</li><li><code>varying vec2 vTexCoord</code> contains the coordinates on the canvas of the current pixel, ranging from 0 to 1.</li></ul><p>Combining these, <code>texture2D(tex0, vTexCoord)</code> returns the color of the current pixel on the canvas, which you can then modify. In this example, we create a custom black-and-white filter by replacing the red and green channels with the blue channel:</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let video;\nlet bw;\n\nlet bwSrc = `\nprecision highp float;\n\nuniform sampler2D tex0;\nvarying vec2 vTexCoord;\n\nvoid main() {\n  // Get the original color for this pixel\n  vec4 color = texture2D(tex0, vTexCoord);\n\n  // Make it black and white by replacing all channels with blue\n  color.r = color.b;\n  color.g = color.b;\n\n  // Set the new color\n  gl_FragColor = color;\n}\n`;\n\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  video = createVideo(\n    &#39;https://upload.wikimedia.org/wikipedia/commons/d/d2/DiagonalCrosswalkYongeDundas.webm&#39;\n  );\n  video.volume(0);\n  video.hide();\n  video.loop();\n  \n  bw = createFilterShader(bwSrc);\n  \n  describe(&#39;A video of a city crosswalk in black and white&#39;);\n}\n\nfunction draw() {\n  background(255);\n  push();\n  imageMode(CENTER);\n  image(video, 0, 0, width, height, 0, 0, video.width, video.height, COVER);\n  pop();\n  filter(bw);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=bUlQx><div class=code-placeholder></div></astro-island><p>Another thing you might want to try is modifying the <em>input</em> to <code>texture2D</code> rather than modifying its output. Adjusting the texture coordinate used can create an offset from the original or a warp effect if the offset is different per pixel:</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let video;\nlet warp;\n\nlet warpSrc = `\nprecision highp float;\n\nuniform sampler2D tex0;\nvarying vec2 vTexCoord;\n\nvoid main() {\n  // Offset the input coordinate\n  vec2 warpedCoord = vTexCoord;\n  warpedCoord.x += 0.05 * sin(vTexCoord.y * 10.0);\n  warpedCoord.y += 0.05 * sin(vTexCoord.x * 10.0);\n\n  // Set the new color by looking up the warped coordinate\n  gl_FragColor = texture2D(tex0, warpedCoord);\n}\n`;\n\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  video = createVideo(\n    &#39;https://upload.wikimedia.org/wikipedia/commons/d/d2/DiagonalCrosswalkYongeDundas.webm&#39;\n  );\n  video.volume(0);\n  video.hide();\n  video.loop();\n  \n  warp = createFilterShader(warpSrc);\n  \n  describe(&#39;A warped video of a city crosswalk&#39;);\n}\n\nfunction draw() {\n  background(255);\n  push();\n  imageMode(CENTER);\n  image(video, 0, 0, width, height, 0, 0, video.width, video.height, COVER);\n  pop();\n  filter(warp);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=2510p5><div class=code-placeholder></div></astro-island><h2 id=conclusion>Conclusion</h2><p>With these skills you can create some basic shaders, but shader programming can go much further, and many shader topics go beyond this tutorial. Shaders in p5.js can be a powerful tool for creating visuals, effects, and textures that can be mapped to your 3D geometry.</p><p>Want to keep learning more about shaders? Check out some of these websites!</p><ul><li><a href=https://thebookofshaders.com/ >The Book of Shaders</a>, a shader guide by Patricio Gonzalez Vivo and Jen Lowe.</li><li><a href=https://itp-xstory.github.io/p5js-shaders/#/ >p5.js shaders</a>, a shader guide by Casey Conchinha and Louise Lessél.</li><li><a href=https://www.shadertoy.com/ >Shadertoy</a>, a massive online collection of shaders that are written in a browser editor.</li><li><a href=https://github.com/aferriss/p5jsShaderExamples>p5js Shader Examples</a>, a collection of resources by Adam Ferriss.</li><li><a href=https://registry.khronos.org/OpenGL/specs/es/2.0/es_cm_spec_2.0.pdf>OpenGL ES 2.0 Specification</a>, super technical specification for GLSL</li><li><a href=https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf>WebGL Quick Reference card</a>, another slightly dense technical reference, but it contains lots of goodies about GLSL functions</li><li><a href=https://shaderific.com/glsl.html>Shaderific GLSL ES reference</a>, a somewhat slimmed-down reference for built-in GLSL functions and data types </li></ul><h2 id=glossary>Glossary</h2><h4 id=shader>Shader</h4><p>A special graphics card program that can efficiently produce many visual effects and filters.</p><h4 id=glsl>GLSL</h4><p>Graphics Library Shader Language (GLSL) is a programming language that is used to write shaders.</p><h4 id=uniform>Uniform</h4><p>A variable that is passed from your sketch to a shader.</p><h4 id=varying>Varying</h4><p>A variable that is passed from the vertex shader to the fragment shader</p><h4 id=vector-vec2--vec3--vec4>Vector (<code>vec2</code> / <code>vec3</code> / <code>vec4</code>)</h4><p>A data type that stores a group of numbers, most commonly two, three, or four, to represent colors, positions, and more.</p><h4 id=float>Float</h4><p>A data type that stores floating point numbers, which can have a decimal point.</p><h4 id=int>Int</h4><p>A data type that stores integers, which are whole numbers without a decimal.</p><h4 id=sampler>Sampler</h4><p>A data type that represents a texture being passed into the shader. Typically expressed as a <code>sampler2D</code> in GLSL.</p><h4 id=attribute>Attribute</h4><p>A GLSL variable that is generated in the p5.js sketch and made available in the vertex shader. For most situations these are provided by p5.js.</p><h4 id=texture>Texture</h4><p>An image that is passed into a shader program. Can be sampled using the <code>texture2D()</code> function.</p><h4 id=type>Type</h4><p>A label describing the format of a piece of data, such as an int, a float, a vector, etc.</p><h4 id=vertex-shader>Vertex Shader</h4><p>The part of a shader program that is responsible for positioning geometry in 3D space.</p><h4 id=fragment-shader>Fragment Shader</h4><p>The part of a shader program that is responsible for the color and appearance of each pixel output by the shader.</p><h2>Related examples</h2><ul></ul><h2>Related references</h2><ul></ul></main><div>p5.js site footer goes here</div></body></html>