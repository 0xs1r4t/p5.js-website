<!DOCTYPE html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_astro/_slug_.C79K3bky.css rel=stylesheet /></head><body><nav><ul><a href=/ >Home</a> <a href=/reference>Reference</a> <a href=/tutorials>Tutorials</a> <a href=/examples>Examples</a> <a href=/community>Community</a> <a href=/about>About</a> <a href=/contribute>Contribute</a></ul></nav><div class="flex space-x-2"><select id=locale-select><option value=/tutorials/lights-camera-materials/ selected=true>English</option><option value=/ar/tutorials/lights-camera-materials/ >العربية</option><option value=/es/tutorials/lights-camera-materials/ >español</option><option value=/hi/tutorials/lights-camera-materials/ >हिन्दी</option><option value=/ko/tutorials/lights-camera-materials/ >한국어</option><option value=/pt-br/tutorials/lights-camera-materials/ >português (Brasil)</option><option value=/sk/tutorials/lights-camera-materials/ >slovenčina</option><option value=/zh/tutorials/lights-camera-materials/ >中文</option></select><script>document.getElementById("locale-select")?.addEventListener("change",(function(){window.location.href=this.value}))</script><div><form action=/search method=GET role=search><label for=search-term>Search</label> <input aria-label="Search through site content" class="border border-black" id=search-term name=term required type=search> <button type=submit>Search</button></form></div><div>Language: en</div><div>Accessibility</div></div><h1 class="font-bold text-lg">Lights, Camera, Materials</h1><span></span><main><h6>By Dave Pagurek, Austin Lee Slominski, Adam Ferriss</h6><p>Creating in 3D is about more than just geometry. Cameras, lights, and materials are important parts of creating a visually interesting 3D scene. p5.js has a number of tools that make it possible to transform the appearance of our geometry.</p><h2 id=camera-and-view>Camera and view</h2><p>The camera is an essential piece of a 3D scene. It gives us a sense of space and dimension and helps us frame our content. WebGL mode provides a perspective camera by default, but we can change this using the <code>perspective()</code> or <code>ortho()</code> functions.</p><p><img alt="An illustration showing the difference between perspective and orthographic camera types. In the orthographic view, lines move parallel to each other, where in the perspective view, lines converge." src=/_astro/cameraTypeIllustration.Dpk6dYPw_kE1iL.webp decoding=async height=300 loading=lazy width=720></p><p>A <em>perspective</em> camera skews objects so that they appear smaller as they get further away, vanishing at a single point in the distance. This is in contrast to an <em>orthographic</em> camera, where the geometry stays the same size as it gets further away and has no vanishing point. You can play around with both options in the example below.</p><iframe aria-label="Code Preview" height=400 sandbox="allow-scripts allow-popups allow-modals allow-forms" srcdoc="&lt;!DOCTYPE html>
&lt;meta charset=&quot;utf8&quot; />
&lt;style type='text/css'>
html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
}
body {
  padding: 0;
  margin: 0;
  font-family: monospace;
  font-size: 14px;
  background-color: #dcdcdc
}

#pageContainer {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

#pageContainer>div {
  display: flex;
  flex-direction: column;
  text-align: center;
  justify-content: space-evenly;
  margin: 0px 5px;
}

#controlsContainer {
  width: 250px;
  flex-grow: 2;
}

#controlsContainer label {
  padding: 10px;
}

&lt;/style>
&lt;body>&lt;div id=&quot;pageContainer&quot;>
  &lt;div id=&quot;sketchContainer&quot;>&lt;/div>
  &lt;div id=&quot;controlsContainer&quot;>
    &lt;label>Ortho:
      &lt;input id=&quot;cameraTypeOrtho&quot; name=&quot;cameraType&quot; type=&quot;radio&quot; />          
    &lt;/label>
    &lt;label>Perspective:
      &lt;input id=&quot;cameraTypePerspective&quot; name=&quot;cameraType&quot; type=&quot;radio&quot; checked/>          
    &lt;/label>

    &lt;label>camera fov: &lt;input id=&quot;cameraFov&quot; type=&quot;range&quot; step=&quot;0.001&quot; min=&quot;69&quot; max=&quot;72.5&quot; value=&quot;70&quot;/>&lt;/label>    

    &lt;label>x position: &lt;input id=&quot;cameraPosX&quot; type=&quot;range&quot; step=&quot;0.1&quot; min=&quot;-500&quot; max=&quot;500&quot; value=&quot;200&quot;/>&lt;/label>    
    &lt;label>y position: &lt;input id=&quot;cameraPosY&quot; type=&quot;range&quot; step=&quot;0.1&quot; min=&quot;-500&quot; max=&quot;500&quot; value=&quot;-200&quot;/>&lt;/label>    
    &lt;label>z position: &lt;input id=&quot;cameraPosZ&quot; type=&quot;range&quot; step=&quot;0.1&quot; min=&quot;-500&quot; max=&quot;500&quot; value=&quot;200&quot;/>&lt;/label>   
    
    &lt;p id=&quot;methodText&quot;>&lt;/p>
  &lt;/div>
&lt;/div>
&lt;/body>
&lt;script id=&quot;code&quot; type=&quot;text/javascript&quot;>let fovSlider;
let camPosX, camPosY, camPosZ;
let cameraTypeOrtho, cameraTypePerspective;
let methodText;

function setup() {
  let canvas = createCanvas(350, 350, WEBGL);
  canvas.parent('sketchContainer');

  debugMode();

  fovSlider = document.querySelector('#cameraFov');
  cameraTypeOrtho = document.querySelector('#cameraTypeOrtho');
  cameraTypePerspective = document.querySelector('#cameraTypePerspective');

  camPosX = document.querySelector('#cameraPosX');
  camPosY = document.querySelector('#cameraPosY');
  camPosZ = document.querySelector('#cameraPosZ');

  methodText = document.querySelector('#methodText');

  describe(
    'an interactive sketch that allows you to move either an ortho camera or a perspective camera in 3D, as well as change the perspective camera FOV'
  );
}

function draw() {
  background(220);

  if (cameraTypeOrtho.checked) {
    camera(camPosX.value, camPosY.value, camPosZ.value);
    ortho(-width / 2, width / 2, -height / 2, height / 2, 0, 800);
  } else if (cameraTypePerspective.checked) {
    camera(camPosX.value, camPosY.value, camPosZ.value);
    perspective(fovSlider.value);
  }

  box(50);

  methodText.innerHTML = cameraTypeOrtho.checked
    ? 'ortho(); &lt;/br>'
    : 'perspective(' + parseFloat(fovSlider.value).toFixed(1) + '); &lt;/br>';
  methodText.innerHTML +=
    '&lt;br />camera(' +
    parseFloat(camPosX.value).toFixed(1) +
    ',' +
    parseFloat(camPosY.value).toFixed(1) +
    ',' +
    parseFloat(camPosZ.value).toFixed(1) +
    ');';

  fovSlider.disabled = cameraTypeOrtho.checked;
}
&lt;/script>
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.min.js&quot;>&lt;/script>
" title="Code Preview" width=100%></iframe><p><em>Field-of-view,</em> or FOV, is the term used to describe how much our camera can see, measured in angle. In simple examples, it might appear to have a zoom-like effect, but larger FOV angles cause shapes to have more perspective distortion. Sometimes, this effect is <a href=https://en.wikipedia.org/wiki/Dolly_zoom>used for artistic purposes.</a></p><iframe aria-label="Code Preview" height=400 sandbox="allow-scripts allow-popups allow-modals allow-forms" srcdoc="&lt;!DOCTYPE html>
&lt;meta charset=&quot;utf8&quot; />
&lt;style type='text/css'>
html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
}

&lt;/style>
&lt;body>&lt;/body>
&lt;script id=&quot;code&quot; type=&quot;text/javascript&quot;>let fovDisplay;
let distDisplay;
let w = 200
let h = 200

let cameraView
let outsideView

function setup() {
  createCanvas(2*w, h, WEBGL);
  cameraView = createFramebuffer({ width: w, height: h });
  outsideView = createFramebuffer({ width: w, height: h });
  fovDisplay = createP().position(0, 200);
  distDisplay = createP().position(0, 230);
}

function draw() {
  background(255);
  noStroke();
  
  const distanceAway = map(
    sin(millis() * 0.001),
    -1, 1,
    80, 600
  );
  const fov = 2 * Math.atan(h / 2 / distanceAway);
  fovDisplay.html(`FOV: ${round(degrees(fov))}°`)
  distDisplay.html(`Distance: ${round(distanceAway)}`)
  
  const drawScene = () => {
    push();
    translate(-70, -70, 0);
    normalMaterial();
    sphere(20);
    pop();

    push();
    translate(70, 70, 0);
    rotateY(PI*0.1);
    normalMaterial();
    torus(20, 5);
    pop();

    push()
    translate(0, 0, -100);
    rotateX(PI/4);
    rotateY(PI/4);
    normalMaterial();
    box(80);
    pop();
  };
  
  cameraView.draw(() => {
    background(255, 220, 220);
    camera(0, 0, distanceAway);
    perspective(fov, w/h, 0.1, 1000);
    drawScene();
  });
  outsideView.draw(() => {
    background(220, 220, 255);
    translate(0, -200, -1800);    
    
    // Visualize camera view
    push();
    fill(255, 0, 0, 100);
    const extend = 400;
    const totalDist = distanceAway + extend;
    triangle(
      0, distanceAway,
      -w/2 * (totalDist/distanceAway), -extend,
      w/2 * (totalDist/distanceAway), -extend,
    );
    pop();
    
    push();
    stroke(255, 0, 0);
    strokeWeight(20);
    line(-w/2, 0, w/2, 0);
    pop();
    drawingContext.clear(drawingContext.DEPTH_BUFFER_BIT);
    
    push();
    rotateX(-PI/2);
    drawScene();
    pop();
  });
  
  imageMode(CENTER);
  image(cameraView, -w/2, 0);
  image(outsideView, w/2, 0);
}
&lt;/script>
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.min.js&quot;>&lt;/script>
" title="Code Preview" width=400></iframe><p>Another important term to understand when working with cameras in 3D is the camera <em>frustum</em>. The frustum of the camera is the shape of the camera’s view. It is a pyramid-like shape within which geometry will be displayed. The frustum includes two components, a <em>near plane</em> and a <em>far plane</em>. The near plane defines the minimum distance that geometry must be from the camera to be rendered. The far plane defines the maximum distance that the geometry can be from the camera and still be seen. Each of these can be changed to affect how close and how far the camera can see. This process of selectively including geometry is sometimes referred to as “clipping.” You can set these using <code>perspective()</code> like so:</p><pre class="astro-code github-dark" style=background-color:#24292e;color:#e1e4e8;overflow-x:auto tabindex=0><code><span class=line><span style=color:#b392f0>perspective</span><span style=color:#e1e4e8>(</span></span>
<span class=line><span style=color:#e1e4e8>  fieldOfViewY, </span><span style=color:#6a737d>// Angle, in radians</span></span>
<span class=line><span style=color:#e1e4e8>  aspectRatio, </span><span style=color:#6a737d>// width / height</span></span>
<span class=line><span style=color:#e1e4e8>  nearPlaneDistance, </span><span style=color:#6a737d>// Minimum distance from camera</span></span>
<span class=line><span style=color:#e1e4e8>  farPlaneDistance </span><span style=color:#6a737d>// Maximum distance from camera</span></span>
<span class=line><span style=color:#e1e4e8>);</span></span></code></pre><p><img alt="An illustration showing the camera frustum in purple, the near plane represented by a yellow rectangle near the camera, and the far plane as a green rectangle on the opposite end of the frustum volume." src=https://lh7-us.googleusercontent.com/lb4mjeBnO7XGB_IG9skfv1fg_1zsU7L6bCIFJQwhdLrmY3srePy8spLLw3SeEslNLu3o8Os6oAUqYQdVKL8b9rIPYTYKYTufoggVm8Ap7cimooNoajq6aS0u4yk2eaHWM7zmV3L9RgOQeuBNJwuPeRM /></p><p>You can move cameras by passing arguments to <code>camera()</code>, but constantly moving and adjusting the camera in code can be tedious. <a href=/reference/en/p5/orbitControl><code>orbitControl()</code></a> can be used to zoom, pan, and position the camera using the mouse. You can use it by calling it at the beginning your <code>draw()</code> function, outside of any <code>push()</code> and <code>pop()</code> calls:</p><style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(self.Astro||(self.Astro={})).load=async t=>{await(await t())()},window.dispatchEvent(new Event("astro:load")),(()=>{var t,e=Object.defineProperty,r=(t,r,n)=>(((t,r,n)=>{r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[r]=n})(t,"symbol"!=typeof r?r+"":r,n),n);{let e={0:t=>i(t),1:t=>s(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(s(t)),5:t=>new Set(s(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},n=t=>{let[r,n]=t;return r in e?e[r](n):void 0},s=t=>t.map(n),i=t=>"object"!=typeof t||null===t?t:Object.fromEntries(Object.entries(t).map((([t,e])=>[t,n(e)])));customElements.get("astro-island")||customElements.define("astro-island",(t=class extends HTMLElement{constructor(){super(...arguments),r(this,"Component"),r(this,"hydrator"),r(this,"hydrate",(async()=>{var t;if(!this.hydrator||!this.isConnected)return;let e=null==(t=this.parentElement)?void 0:t.closest("astro-island[ssr]");if(e)return void e.addEventListener("astro:hydrate",this.hydrate,{once:!0});let r,n=this.querySelectorAll("astro-slot"),s={},o=this.querySelectorAll("template[data-astro-template]");for(let t of o){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("data-astro-template")||"default"]=t.innerHTML,t.remove())}for(let t of n){let e=t.closest(this.tagName);null!=e&&e.isSameNode(this)&&(s[t.getAttribute("name")||"default"]=t.innerHTML)}try{r=this.hasAttribute("props")?i(JSON.parse(this.getAttribute("props"))):{}}catch(t){let e=this.getAttribute("component-url")||"<unknown>",r=this.getAttribute("component-export");throw r&&(e+=` (export ${r})`),console.error(`[hydrate] Error parsing props for component ${e}`,this.getAttribute("props"),t),t}await this.hydrator(this)(this.Component,r,s,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))})),r(this,"unmount",(()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))}))}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(this.hasAttribute("await-children")&&"interactive"!==document.readyState&&"complete"!==document.readyState){let t=()=>{document.removeEventListener("DOMContentLoaded",t),e.disconnect(),this.childrenConnectedCallback()},e=new MutationObserver((()=>{var e;(null==(e=this.lastChild)?void 0:e.nodeType)===Node.COMMENT_NODE&&"astro:end"===this.lastChild.nodeValue&&(this.lastChild.remove(),t())}));e.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",t)}else this.childrenConnectedCallback()}async childrenConnectedCallback(){let t=this.getAttribute("before-hydration-url");t&&await import(t),this.start()}async start(){let t=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(void 0!==Astro[e])try{await Astro[e]((async()=>{let t=this.getAttribute("renderer-url"),[e,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),t?import(t):()=>()=>{}]),n=this.getAttribute("component-export")||"default";if(n.includes(".")){this.Component=e;for(let t of n.split("."))this.Component=this.Component[t]}else this.Component=e[n];return this.hydrator=r,this.hydrate}),t,this)}catch(t){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,t)}else window.addEventListener(`astro:${e}`,(()=>this.start()),{once:!0})}attributeChangedCallback(){this.hydrate()}},r(t,"observedAttributes",["props"]),t))}})()</script><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;function setup() {\n  createCanvas(200, 200, WEBGL);\n  debugMode();\n  describe(&#39;A cube you can look around by clicking and dragging&#39;);\n}\nfunction draw() {\n  background(220);\n \n  orbitControl();\n  box(50);\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=ZWPw4f><div class=code-placeholder></div></astro-island><div class=callout><h5>Try this!</h5><p>Try building a sculpture out of cubes that looks like one thing from one side, but something else when you orbit to a different side.</p></div><h2 id=lighting>Lighting</h2><p>Light is another essential part of a 3D scene, helping convey shape and depth. p5.js has a few different types of light that can be used in a sketch:</p><ul><li><a href=/reference/en/p5/ambientLight><code>ambientLight()</code></a>: Ambient light makes everything display a little brighter, with no consideration for light position or direction.</li><li><a href=/reference/en/p5/directionalLight><code>directionalLight()</code></a>: A directional light is a light without a position that shines from a single angle, which can be especially useful for communicating depth in a scene, or when a scene needs a ‘sun’ light. This function accepts color and direction arguments.</li><li><a href=/reference/en/p5/pointLight><code>pointLight()</code></a>: A point light emits light from a single point in all directions, similar to a lightbulb. This function accepts color and position arguments.</li><li><a href=/reference/en/p5/spotLight><code>spotLight()</code></a>: A spot light emits light from a single point in a single direction. This light is cast in a conical shape and its radius and concentration can be adjusted.</li><li><a href=/reference/en/p5/imageLight><code>imageLight()</code></a>: Using an image as a light source is like placing your scene inside a huge sphere textured with that image, sending light into the scene.</li><li><a href=/reference/en/p5/noLight><code>noLight()</code></a>: Makes it so that all subsequently drawn geometry is rendered without any lighting. This can be useful when you want flat, unshaded geometry.</li></ul><p>These lights should be used within <code>draw()</code>. One image light and up to 5 lights of each other kind can be used simultaneously per shape drawn, allowing you to compose a scene with varied and complex lighting sources. You can also contain light functions within <code>push()</code> and <code>pop()</code> to contain lights to just one section of code, allowing you to use a different set of lights for another shape. Since lighting is done per shape, each object in a scene will not cast shadows on other objects.</p><p>Try checking and unchecking the boxes in the following interactive example to see how lighting can be blended together. For each active light source there are visual indicators of their position or direction, just know that these are here for illustrative purposes!</p><iframe aria-label="Code Preview" height=400 sandbox="allow-scripts allow-popups allow-modals allow-forms" srcdoc="&lt;!DOCTYPE html>
&lt;meta charset=&quot;utf8&quot; />
&lt;style type='text/css'>
html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
}
body {
  padding: 0;
  margin: 0;
  font-family: monospace;
  font-size: 14px;
  background-color: #dcdcdc
}

#pageContainer {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

#pageContainer>div {
  display: flex;
  flex-direction: column;
  text-align: center;
  justify-content: space-evenly;
  margin: 0px 5px;
}

#controlsContainer {
  width: 250px;
  flex-grow: 2;
}

#controlsContainer label {
  padding: 10px;
}

&lt;/style>
&lt;body>&lt;div id=&quot;pageContainer&quot;>
  &lt;div id=&quot;sketchContainer&quot;>&lt;/div>
  &lt;div id=&quot;controlsContainer&quot;>

      &lt;label style=&quot;color:black;&quot;>
        ambient: &lt;input id=&quot;toggleAmbient&quot; type=&quot;checkbox&quot; checked/>
      &lt;/label>
      
      &lt;label style=&quot;color:red;&quot;>
        directional: &lt;input id=&quot;toggleDirectional&quot; type=&quot;checkbox&quot; checked/>
      &lt;/label>
      
      &lt;label style=&quot;color:green;&quot;>
        spotlight: &lt;input id=&quot;toggleSpotlight&quot; type=&quot;checkbox&quot; checked/>
      &lt;/label>
      
      &lt;label style=&quot;color:blue;&quot;>
        point: &lt;input id=&quot;togglePoint&quot; type=&quot;checkbox&quot; checked/>
      &lt;/label>
    
      &lt;label style=&quot;color:magenta;&quot;>
        image: &lt;input id=&quot;toggleImage&quot; type=&quot;checkbox&quot; />
      &lt;/label>
    
&lt;!--         &lt;label style=&quot;color:black;&quot;>
        reflections: &lt;input id=&quot;toggleReflections&quot; type=&quot;checkbox&quot;/>
      &lt;/label> -->

  &lt;/div>
&lt;/div>
&lt;/body>
&lt;script id=&quot;code&quot; type=&quot;text/javascript&quot;>let toggleAmbient, toggleDirectional, toggleSpotlight, togglePoint, toggleImage;

let pointX, pointY, pointZ;
let spotX, spotY, spotZ;
let directionX, directionY, directionZ;
// let reflections;
let spheremap;

function preload() {
  spheremap = loadImage('/images/tutorials/outdoor_spheremap.jpg');
}

function setup() {
  let canvas = createCanvas(350, 350, WEBGL);
  canvas.parent(&quot;sketchContainer&quot;);

  toggleAmbient = document.querySelector(&quot;#toggleAmbient&quot;);
  toggleDirectional = document.querySelector(&quot;#toggleDirectional&quot;);
  toggleSpotlight = document.querySelector(&quot;#toggleSpotlight&quot;);
  togglePoint = document.querySelector(&quot;#togglePoint&quot;);
  toggleImage = document.querySelector(&quot;#toggleImage&quot;);
  // reflections = document.querySelector(&quot;#toggleReflections&quot;);
  
  camera(700, -100, 700);

  describe(
    'an interactive sketch that allows you to toggle on and off a number of different lights with indicators on a box shape.'
  );
}

function draw() {
  background(220);
  orbitControl();

  noStroke();

  directionX = 0
  directionY = -1
  directionZ = 0

  pointX = 80;
  pointY = -20;
  pointZ = 0;

  spotX = 0
  spotY = -10
  spotZ = 150

  push();
  if (toggleAmbient.checked) ambientLight(50);

  if (toggleDirectional.checked) directionalLight(255, 0, 0, -0.25, 0.25, 0);

  if (toggleSpotlight.checked) spotLight(0, 255, 0, spotX, spotY, spotZ, 0, 0, -1);

  if (togglePoint.checked) pointLight(0, 0, 255, pointX, pointY, pointZ);
  
  if (toggleImage.checked) imageLight(spheremap);

  fill(255);
  // if (reflections.checked) {
  //   specularMaterial(255);
  //   shininess(100);
  // }
  sphere(50);
  
  fill(200);
  for (const [ry, rx] of [[0, 0], [PI/2, 0], [0, PI/2]]) {
    push();
    rotateX(rx);
    rotateY(ry);
    translate(0, 0, -100);
    plane(200, 200);
    pop();
  }
  pop();

  // draw debug directional light
  if (toggleDirectional.checked) {
    push();
    translate(0,-150,0);
    rotateZ(PI/4);
    scale(0.15);
    fill('red');
    cone();
    translate(0, -50, 0)
    cylinder(20, 100);
    pop();  
  }

  // draw debug spotlight
  if (toggleSpotlight.checked) {
    push();
    translate(spotX, spotY, spotZ);
    scale(0.3);
    rotateX(PI /2)
    fill('green');
    cone();
    pop();  
  }

  // draw debug point light
  if (togglePoint.checked) {
    push();
    translate(pointX, pointY, pointZ);
    scale(0.2);
    fill('blue');
    sphere();
    pop();
  }
}
&lt;/script>
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.min.js&quot;>&lt;/script>
" title="Code Preview" width=100%></iframe><div class=callout><h5>Try this!</h5><p>Comment and uncomment each light and experiment with their parameters.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;function setup() {\n  createCanvas(200, 200, WEBGL);\n  camera(0,-80, 800);\n  describe(&#39;a box geometry with a number of lights affecting its appearance&#39;);\n}\nfunction draw() {\n  background(220);\n  orbitControl()\n \n  // use comments to enable / disable lights\n \n  ambientLight(20);\n \n  pointLight(\n    255, 0, 0, // color\n    40, -40, 0 // position\n  );\n \n  directionalLight(\n    0,255,0, // color\n    1, 1, 0  // direction\n  );\n \n  let locX = (mouseX - width/2) * 2;\n  let locY = (mouseY - height/2) * 2;\n  spotLight(\n    100, 100, 255, // color\n    locX, locY, 200, // position\n    -locX, -locY, -200, // direction\n    PI/3 // radius of the spotlight cone\n  );\n \n  // noLights();\n \n  rotateY(millis() * 0.001);\n  box();\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=Z1j9OLC><div class=code-placeholder></div></astro-island></div><h2 id=materials-and-textures>Materials and textures</h2><p>Objects can appear different based on their material properties. Materials dictate how light interacts with the geometry and how color (or texture) applies to the object. Materials can be varied, making objects shiny, rough, or textured with images.</p><p>There are five material properties in p5.js that combine to control the look of an object:</p><ul><li><a href=/reference/en/p5/fill><code>fill()</code></a>: This is the color used when there are no lights in the scene. When lights are added, this color mixes with the <em>diffuse</em> component of the light: the bright and dark areas of the surface due to light being directly cast on it.</li><li><a href=/reference/en/p5/ambientMaterial><code>ambientMaterial()</code></a>: This is a color that mixes with the <code>ambientLight()</code> set in the scene. If it is not set, this will be the same as the fill color.</li><li><a href=/reference/en/p5/specularMaterial><code>specularMaterial()</code></a>: This is a color that mixes with the <em>specular</em> component of the light: the reflected highlights on the surface of the shape. If this is not set, there will be no highlights on the shape.</li><li><a href=/reference/en/p5/shininess><code>shininess()</code></a>: This number represents how sharp the specular highlights are. A value of 1 gives spread-out, blurry highlights. The higher the shininess, the sharper and smaller the highlights get. This only makes a difference if a specular material has been set.</li><li><a href=/reference/en/p5/emissiveMaterial><code>emissiveMaterial()</code></a>: This is a color that gets added to the shape. It represents the light that the shape produces on its own, so it does not vary based on the other lights in the scene.</li></ul><p>To determine the color of each pixel, each material component interacts with the scene’s lights before being added together.</p><p>There is one other material setting called <code>normalMaterial()</code>. If this is set, all other material settings are ignored, and the color of the shape is based on the angle of its surface. If the surface is angled horizontally, it will appear more red. If it is angled vertically, it will appear more green. If it is angled towards the camera, it will appear more blue. This is often helpful for debugging shapes.</p><p>In the interactive example below, try selecting each of the different materials to see how they affect the appearance of the geometry.</p><iframe aria-label="Code Preview" height=400 sandbox="allow-scripts allow-popups allow-modals allow-forms" srcdoc="&lt;!DOCTYPE html>
&lt;meta charset=&quot;utf8&quot; />
&lt;style type='text/css'>
html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
}
body {
  padding: 0;
  margin: 0;
  font-family: monospace;
  font-size: 14px;
  background-color: #dcdcdc
}

#pageContainer {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

#pageContainer>div {
  display: flex;
  flex-direction: column;
  text-align: center;
  justify-content: space-evenly;
  margin: 0px 5px;
}

#controlsContainer {
  width: 250px;
  flex-grow: 2;
}

#controlsContainer label {
  padding: 10px;
}

&lt;/style>
&lt;body>&lt;div id=&quot;pageContainer&quot;>
  &lt;div id=&quot;sketchContainer&quot;>&lt;/div>
  &lt;div id=&quot;controlsContainer&quot;>
    &lt;label>
      fill: &lt;input type=&quot;color&quot; id=&quot;fillColor&quot; value=&quot;#FFFFFF&quot; />
    &lt;/label>
    
    &lt;label>
      ambientMaterial: &lt;input id=&quot;toggleAmbientMaterial&quot; name=&quot;materialSelect&quot; type=&quot;checkbox&quot;/> &lt;input type=&quot;color&quot; id=&quot;ambientColor&quot; value=&quot;#DD5500&quot; />
    &lt;/label>
    
    &lt;label>
      emissiveMaterial: &lt;input id=&quot;toggleEmissiveMaterial&quot; name=&quot;materialSelect&quot; type=&quot;checkbox&quot;/> &lt;input type=&quot;color&quot; id=&quot;emissiveColor&quot; value=&quot;#3E6BB8&quot; />
    &lt;/label>
    
    &lt;label>
      specularMaterial: &lt;input id=&quot;toggleSpecularMaterial&quot; name=&quot;materialSelect&quot; type=&quot;checkbox&quot;/> &lt;input type=&quot;color&quot; id=&quot;specularColor&quot; value=&quot;#AAAAAA&quot; />
    &lt;/label>
    
    &lt;label>
      shininess: &lt;input id=&quot;shininessSlider&quot; type=&quot;range&quot; min=&quot;1&quot; max=&quot;300&quot; value=&quot;100&quot; disabled />
    &lt;/label>
    
    &lt;label>
      normalMaterial: &lt;input id=&quot;toggleNormalMaterial&quot; name=&quot;materialSelect&quot; type=&quot;checkbox&quot; /> 
    &lt;/label>
  &lt;/div>
&lt;/div>
&lt;/body>
&lt;script id=&quot;code&quot; type=&quot;text/javascript&quot;>let toggleNormalMaterial;
let toggleAmbientMaterial;
let toggleEmissiveMaterial;
let toggleSpecularMaterial;
let shininessSlider;

let ambientColorPicker;
let emissiveColorPicker;
let specularColorPicker;
let fillColorPicker;

let isUserChange = true;

function setup() {
  let canvas = createCanvas(350, 350, WEBGL);
  canvas.parent(&quot;sketchContainer&quot;);

  debugMode();

  toggleNormalMaterial = document.querySelector('#toggleNormalMaterial');
  toggleAmbientMaterial = document.querySelector('#toggleAmbientMaterial');
  toggleEmissiveMaterial = document.querySelector('#toggleEmissiveMaterial');
  toggleSpecularMaterial = document.querySelector('#toggleSpecularMaterial');
  shininessSlider = document.querySelector('#shininessSlider');
  
  ambientColorPicker = document.querySelector('#ambientColor');
  emissiveColorPicker = document.querySelector('#emissiveColor');
  specularColorPicker = document.querySelector('#specularColor');
  fillColorPicker = document.querySelector('#fillColor');
  
  const allChecks = [
    toggleNormalMaterial,
    toggleAmbientMaterial,
    toggleEmissiveMaterial,
    toggleSpecularMaterial
  ];
  for (const check of allChecks) {
    check.addEventListener('change', (e) => {
      if (!isUserChange) return;
      
      isUserChange = false;
      if (e.target === toggleNormalMaterial &amp;&amp; toggleNormalMaterial.checked) {
        for (const other of allChecks) {
          if (other === toggleNormalMaterial) continue;
          other.checked = false;
        }
      } else if (e.target !== toggleNormalMaterial &amp;&amp; e.target.checked) {
        toggleNormalMaterial.checked = false;
      }
      shininessSlider.disabled = !toggleSpecularMaterial.checked;
      isUserChange = true;
    })
  }

  describe('an interactive example that allows you to toggle different materials on either a box or sphere shape');
}

function draw() {
  background(220);
  camera(
    50 * sin(millis()*0.002), -100, 500, // position
    0, 0, 0 // look at
  );
  
  noStroke();

  push()
  let locX = 50
  let locY = -100;
  directionalLight(127, 127, 127, 1.0-locX, 1.0-locY, -1);
  ambientLight(64);

  if(toggleNormalMaterial.checked) {
    normalMaterial();
  } else {
    fill(fillColorPicker.value);
  }

  if(toggleAmbientMaterial.checked) {
    ambientMaterial(ambientColorPicker.value);
  }

  if(toggleEmissiveMaterial.checked) {
    emissiveMaterial(emissiveColorPicker.value);
  }

  if(toggleSpecularMaterial.checked) {
    specularMaterial(specularColorPicker.value);
    shininess(parseFloat(shininessSlider.value));
  }

  push();
  torus(40, 20);
  pop();
  pop();
  
  // draw debug point light
  push();
  translate(locX, locY, 50);
  scale(0.2);
  noLights();
  fill('white');
  sphere();
  pop();
}
&lt;/script>
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.min.js&quot;>&lt;/script>
" title="Code Preview" width=100%></iframe><div class=callout><h5>Try this!</h5><p>Comment and uncomment the different lights in this example to see how they interact with the materials:</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;function setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;a sphere geometry with multiple materials applied to it&#39;);\n}\nfunction draw() {\n  background(220);\n  camera(200, -200, 600);\n \n  noStroke();\n  ambientLight(128);\n  let locX = mouseX - width / 2;\n  let locY = mouseY - height / 2;\n  pointLight(255, 255, 255, locX, locY, 100);\n  // normal material shows the geometry normals\n  normalMaterial();\n  // ambient materials reflect under any light\n  ambientMaterial(255, 0, 0);\n  // emissive materials show the same color regardless of light\n  emissiveMaterial(0, 255, 0);\n  // specular materials reflect the color of the light source\n  // and can vary in &#39;shininess&#39;\n  shininess(10);\n  specularMaterial(0, 0, 255);\n  // box(50);\n  sphere();\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=ZGThuC><div class=code-placeholder></div></astro-island></div><p>In WebGL mode, you don’t need to have a single <code>fill()</code> value for the whole shape: you can apply a different fill color to each vertex. If the vertices of a triangle have different fill colors, the triangle will smoothly blend between the colors on the corners. This is a useful way to create smooth gradients across shapes, like in the example below. Try clicking and holding on the canvas to see the edges of the shape to get a sense of where WebGL is filling in the in-between sections for us.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let palette = [\n  &#39;#588b8b&#39;,\n  &#39;#ffffff&#39;,\n  &#39;#ffd5c2&#39;,\n  &#39;#f28f3b&#39;,\n  &#39;#c8553d&#39;\n];\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n\n  describe(&#39;a gradient from teal to white to orange&#39;);\n}\nfunction draw() {\n  background(0);\n \n  // Click and hold on the canvas to see where the edges\n  // of the shapes are. Everything in between is blended for\n  // you by WebGL!\n  if (mouseIsPressed === true) {\n    stroke(255, 0, 255);\n  } else {\n    noStroke();\n  }\n \n  beginShape(QUAD_STRIP);\n  // Create a column of vertices for each color\n  for (let i = 0; i &lt; palette.length; i += 1) {\n    fill(palette[i]);\n    let x = map(i, 0, palette.length-1, -80, 80);\n    vertex(x, -50);\n    vertex(x, 50);\n  }\n  endShape();\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=ZnYCMC><div class=code-placeholder></div></astro-island><p>More custom materials can be achieved by using the <code>texture()</code> function. This allows you to map an image to the surface of a geometry. These textures can be imported from an image and even generated within code using shaders. To map a texture to your geometry, use <code>loadImage()</code> within <code>preload()</code>, then call <code>texture()</code> before drawing your shape.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let myTexture;\nfunction preload() {\n  myTexture = loadImage(&#39;/images/tutorials/simpleTexture.png&#39;);\n}\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;a rotating box with a texture of a pink scribble mapped onto it&#39;);\n}\nfunction draw() {\n  background(220);\n \n  // apply the texture to the box\n  texture(myTexture);\n \n  push();\n  rotateX(millis()/1000);\n  rotateY(millis()/700);\n  box();\n  pop();\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=Z2jeKkE><div class=code-placeholder></div></astro-island><p>When you create custom geometry you can specify a texture coordinate for each vertex after each 3D position. By default, these coordinates are in pixels relative to the texture you have applied, but you can set <code>textureMode(NORMAL)</code> to use a 0-1 range, representing a fraction of the image’s dimensions, which is helpful in making models that work for any image.</p><p>The texture coordinates of a vertex can stay the same while its 3D position changes. You can use this to distort and animate images. In the example below, changing vertex positions while keeping texture coordinates the same is used to wiggle a drawing. Click and hold on the canvas to see the edges of the grid of vertices being drawn.</p><astro-island await-children="" client=load component-export=default component-url=/_astro/CodeEmbed.BxoFCdDb.js opts={&quot;name&quot;:&quot;CodeEmbedCodeMirror&quot;,&quot;value&quot;:true} props="{&quot;initialValue&quot;:[0,&quot;let img;\nfunction preload() {\n  img = loadImage(&#39;/images/tutorials/wiggly-guy.png&#39;);\n}\nfunction setup() {\n  createCanvas(200, 200, WEBGL);\n  describe(&#39;A cartoon drawing of a person wiggling&#39;);\n}\nfunction draw() {\n  background(255);\n  translate(-width/2, -height/2);\n \n  // Click and hold on the canvas to see where the\n  // edges of the shapes are!\n  if (mouseIsPressed === true) {\n    stroke(255, 0, 0);\n  } else {\n    noStroke();\n  }\n \n  let t = millis();\n \n  texture(img);\n \n  // Draw a bunch of vertical strips of quads to make a grid\n  for (let x = 0; x &lt; 200; x += 20) {\n    beginShape(QUAD_STRIP);\n   \n    // Each vertical strip will start from the top and go down\n    for (let y = 0; y &lt;= 200; y += 20) {\n     \n      // Iterate over each side of the strip, left then right\n      for (let offset of [0, 20]) {\n        // (x+offset, y) is the undistorted coordinate for this\n        // vertex on the grid, so we&#39;ll use that for the texture\n        // coordinates.\n        //\n        // For the 3D position of the vertex, we will animate them\n        // moving around over time.\n        let wiggledX = x + offset + 5 * sin(y*0.05 + t*0.01);\n        let wiggledY = y + 5 * sin((x + offset)*0.05 + t*0.01);\n        vertex(\n          // The vertex position is distorted\n          wiggledX, wiggledY, 0,\n          // The texture coordinate is not\n          x+offset, y\n        );\n      }\n    }\n    endShape();\n  }\n}&quot;],&quot;previewable&quot;:[0,true],&quot;editable&quot;:[0,true]}" renderer-url=/_astro/client.CwpMCSBY.js ssr="" uid=1Lb4BC><div class=code-placeholder></div></astro-island><div class=callout><h5>Try this!</h5><p>By distorting vertex positions, can you make an image of a character look like it’s jumping? Waving? Walking?</p></div><h2 id=conclusion>Conclusion</h2><p>Having control over the camera, lighting, and materials will give you more flexibility to change the look of your sketch and open up the possibility for you to introduce your own style to your 3D sketches.</p><p>To make even more advanced materials for your shapes, artists often write <em>shaders.</em> Check out the <a href=./intro-to-shaders>Introduction to Shaders</a> tutorial when you’re ready to explore even more possibilities!</p><h2 id=glossary>Glossary</h2><h4 id=camera>Camera</h4><p>The viewpoint of a 3D scene</p><h4 id=perspective>Perspective</h4><p>A camera projection that gives the appearance of depth, achieved by making objects in the distance appear smaller.</p><h4 id=orthographic>Orthographic</h4><p>A camera projection that is <em>orthogonal</em> and unaffected by depth. It gives the appearance of being two-dimensional.</p><h4 id=field-of-view>Field-of-View</h4><p>The angle representing how much can be seen by the camera.</p><h4 id=frustum>Frustum</h4><p>The geometric shape representing the full area that can be viewed by the camera.</p><h4 id=near-and-far-plane>Near and Far Plane</h4><p>The near plane represents the minimum distance a geometry must be from the camera to be displayed, while the far plane represents the maximum distance.</p><h4 id=clipping>Clipping</h4><p>Selectively showing some geometry and not others, such as when geometry falls outside of the camera frustum.</p><h4 id=diffuse-light>Diffuse Light</h4><p>The effect of light on a matte material. Since matte materials bounce light equally in all directions, the color you see will look the same regardless of your vantage point.</p><h4 id=specular-light>Specular Light</h4><p>The effect of light on a shiny or glossy material, visible as reflected highlights. The positions of the highlights will change as you move around an object as the reflection angles change.</p><h4 id=shininess>Shininess</h4><p>How sharp the specular reflections on an object are. This property comes from how much reflected light spreads out after bouncing off of the surface of an object: the less it spreads out, the sharper the reflections and the shinier the object appears; the more it spreads out, the blurrier the reflections are and the less shiny the object appears.</p><h4 id=emissive-light>Emissive Light</h4><p>Light emitted from the surface of an object, which gets added to the light that comes from external light sources.</p><h4 id=ambient-light>Ambient Light</h4><p>A uniform amount of light coming from all directions, as if the scene were inside a big sphere emitting light.</p><h2>Related examples</h2><ul></ul><h2>Related references</h2><ul></ul></main><div>p5.js site footer goes here</div></body></html>