---
title: endShape
<<<<<<< HEAD
module: आकार
submodule: शीर्ष
file: src/core/shape/vertex.js
description: >
  <p><a href='/reference/p5/endShape'>endShape()</a> फ़ंक्शन <a href='/reference/p5/beginShape'>beginShape()</a> का साथी है और केवल <a href="/reference/p5/beginShape">beginShape()</a> के बाद ही कॉल किया जा सकता है।

  जब <a href="/reference/p5/endshape">endShape()</a> को कॉल किया जाता है, तो <a href="/reference/p5/beginShape">beginShape()</a> पर पिछली कॉल के बाद से परिभाषित सभी छवि डेटा छवि बफ़र में लिख दिया जाता है।

  स्थिर CLOSE आकार को बंद करने (शुरुआत और अंत को जोड़ने के लिए) <code>mode</code> पैरामीटर के लिए मान है।

  <a href="/reference/p5/endShape">endShape()</a> के साथ इंस्टेंसिंग का उपयोग करते समय इंस्टेंसिंग स्ट्रोक पर लागू नहीं होगी।

  जब गिनती पैरामीटर का उपयोग 1 से अधिक मान के साथ किया जाता है, तो यह WEBGL मोड में निर्मित आकृतियों के लिए इंस्टेंसिंग को सक्षम बनाता है।

  इंस्टेंसिंग एक ऐसी सुविधा है जो GPU को उसी के गुणकों को कुशलतापूर्वक खींचने की अनुमति देती है
  आकार।

  इसका उपयोग अक्सर कण प्रभावों या अन्य समयों के लिए किया जाता है जब आपको बहुत अधिक पुनरावृत्ति की आवश्यकता होती है।

  इंस्टेंसिंग का लाभ उठाने के लिए, आपको gl_InstanceID कीवर्ड का उपयोग करके अपना स्वयं का कस्टम शेडर भी लिखना होगा।

  आप इंस्टेंसिंग के बारे में <a href="https://webgl/lessons/webgl-instanced-drawing.html">यहां</a> या इस पेज पर उदाहरण से काम करके अधिक पढ़ सकते हैं।</p>
line: 591
isConstructor: false
itemtype: तरीका
alt: नीचे और ऊपर की ओर सबसे छोटे आंतरिक कोण के साथ त्रिभुज रेखा का आकार L।
=======
module: Shape
submodule: Vertex
file: src/core/shape/vertex.js
description: >
  <p>Begins adding vertices to a custom shape.</p>

  <p>The <a href="/reference/p5/beginShape">beginShape()</a> and
  <code>endShape()</code> functions

  allow for creating custom shapes in 2D or 3D.

  <a href="/reference/p5/beginShape">beginShape()</a> begins adding vertices to
  a

  custom shape and <code>endShape()</code> stops adding them.</p>

  <p>The first parameter, <code>mode</code>, is optional. By default, the first
  and last

  vertices of a shape aren't connected. If the constant <code>CLOSE</code> is
  passed, as

  in <code>endShape(CLOSE)</code>, then the first and last vertices will be
  connected.</p>

  <p>The second parameter, <code>count</code>, is also optional. In WebGL mode,
  it’s more

  efficient to draw many copies of the same shape using a technique called

  <a
  href="https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html"
  target="_blank">instancing</a>.

  The <code>count</code> parameter tells WebGL mode how many copies to draw. For

  example, calling <code>endShape(CLOSE, 400)</code> after drawing a custom
  shape will

  make it efficient to draw 400 copies. This feature requires

  <a href="https://p5js.org/learn/getting-started-in-webgl-shaders.html"
  target="_blank">writing a custom shader</a>.</p>

  <p>After calling <a href="/reference/p5/beginShape">beginShape()</a>, shapes
  can be

  built by calling <a href="/reference/p5/vertex">vertex()</a>,

  <a href="/reference/p5/bezierVertex">bezierVertex()</a>,

  <a href="/reference/p5/quadraticVertex">quadraticVertex()</a>, and/or

  <a href="/reference/p5/curveVertex">curveVertex()</a>. Calling

  <code>endShape()</code> will stop adding vertices to the

  shape. Each shape will be outlined with the current stroke color and filled

  with the current fill color.</p>

  <p>Transformations such as <a href="/reference/p5/translate">translate()</a>,

  <a href="/reference/p5/rotate">rotate()</a>, and

  <a href="/reference/p5/scale">scale()</a> don't work between

  <a href="/reference/p5/beginShape">beginShape()</a> and
  <code>endShape()</code>. It's also not

  possible to use other shapes, such as <a
  href="/reference/p5/ellipse">ellipse()</a> or

  <a href="/reference/p5/rect">rect()</a>, between

  <a href="/reference/p5/beginShape">beginShape()</a> and
  <code>endShape()</code>.</p>
line: 1344
isConstructor: false
itemtype: method
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
example:
  - |-

    <div>
    <code>
<<<<<<< HEAD
    noFill();

    beginShape();
    vertex(20, 20);
    vertex(45, 20);
    vertex(45, 80);
    endShape(CLOSE);

    beginShape();
    vertex(50, 20);
    vertex(75, 20);
    vertex(75, 80);
    endShape();
    </code>
    </div>
  - |-

    <div>
    <code>
    let fx;
    let vs = `#version 300 es
=======
    function setup() {
      createCanvas(100, 100);

      background(200);

      // Style the shapes.
      noFill();

      // Left triangle.
      beginShape();
      vertex(20, 20);
      vertex(45, 20);
      vertex(45, 80);
      endShape(CLOSE);

      // Right triangle.
      beginShape();
      vertex(50, 20);
      vertex(75, 20);
      vertex(75, 80);
      endShape();

      describe(
        'Two sets of black lines drawn on a gray background. The three lines on the left form a right triangle. The two lines on the right form a right angle.'
      );
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `#version 300 es
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86

    precision mediump float;

    in vec3 aPosition;
    flat out int instanceID;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    void main() {

<<<<<<< HEAD
      // copy the instance ID to the fragment shader
      instanceID = gl_InstanceID;
      vec4 positionVec4 = vec4(aPosition, 1.0);

      // gl_InstanceID represents a numeric value for each instance
      // using gl_InstanceID allows us to move each instance separately
      // here we move each instance horizontally by id * 23
      float xOffset = float(gl_InstanceID) * 23.0;

      // apply the offset to the final position
=======
      // Copy the instance ID to the fragment shader.
      instanceID = gl_InstanceID;
      vec4 positionVec4 = vec4(aPosition, 1.0);

      // gl_InstanceID represents a numeric value for each instance.
      // Using gl_InstanceID allows us to move each instance separately.
      // Here we move each instance horizontally by ID * 23.
      float xOffset = float(gl_InstanceID) * 23.0;

      // Apply the offset to the final position.
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
      gl_Position = uProjectionMatrix * uModelViewMatrix * (positionVec4 -
        vec4(xOffset, 0.0, 0.0, 0.0));
    }
    `;
<<<<<<< HEAD
    let fs = `#version 300 es
=======

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `#version 300 es
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86

    precision mediump float;

    out vec4 outColor;
    flat in int instanceID;
    uniform float numInstances;

    void main() {
      vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
      vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);

<<<<<<< HEAD
      // Normalize the instance id
      float normId = float(instanceID) / numInstances;

      // Mix between two colors using the normalized instance id
=======
      // Normalize the instance ID.
      float normId = float(instanceID) / numInstances;

      // Mix between two colors using the normalized instance ID.
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
      outColor = mix(red, blue, normId);
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);
<<<<<<< HEAD
      fx = createShader(vs, fs);
    }

    function draw() {
      background(220);

      // strokes aren't instanced, and are rather used for debug purposes
      shader(fx);
      fx.setUniform('numInstances', 4);

      // this doesn't have to do with instancing, this is just for centering the squares
      translate(25, -10);

      // here we draw the squares we want to instance
=======

      // Create a p5.Shader object.
      let myShader = createShader(vertSrc, fragSrc);

      background(220);

      // Compile and apply the p5.Shader.
      shader(myShader);

      // Set the numInstances uniform.
      myShader.setUniform('numInstances', 4);

      // Translate the origin to help align the drawing.
      translate(25, -10);

      // Style the shapes.
      noStroke();

      // Draw the shapes.
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
      beginShape();
      vertex(0, 0);
      vertex(0, 20);
      vertex(20, 20);
      vertex(20, 0);
      vertex(0, 0);
      endShape(CLOSE, 4);

<<<<<<< HEAD
      resetShader();
=======
      describe('A row of four squares. Their colors transition from purple on the left to red on the right');
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
    }
    </code>
    </div>
class: p5
params:
  - name: mode
    description: |
<<<<<<< HEAD
      <p>आकृति को बंद करने के लिए CLOSE का उपयोग करें</p>
    type: स्थिर
    optional: true
  - name: count
    description: >
      <p>जितनी बार आप आकृति बनाना/उदाहरण बनाना चाहते हैं (वेबजीएल मोड के लिए)।</p>
    type: पूर्णांक
=======
      <p>use CLOSE to close the shape</p>
    type: Constant
    optional: true
  - name: count
    description: >
      <p>number of times you want to draw/instance the shape (for WebGL
      mode).</p>
    type: Integer
>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
    optional: true
chainable: true
---

<<<<<<< HEAD
=======

>>>>>>> d92abe86a6be46eb4f9114440e434084a9b67f86
# endShape
