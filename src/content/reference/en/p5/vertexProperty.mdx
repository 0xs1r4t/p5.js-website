---
title: vertexProperty
module: Shape
submodule: Vertex
file: src/shape/vertex.js
description: >
  <p>Sets the shader's vertex property or attribute variables.</p>

  <p>An vertex property or vertex attribute is a variable belonging to a vertex
  in a shader. p5.js provides some

  default properties, such as <code>aPosition</code>, <code>aNormal</code>,
  <code>aVertexColor</code>, etc. These are

  set using <a href="/reference/p5/vertex/">vertex()</a>, <a
  href="/reference/p5/normal/">normal()</a>

  and <a href="/reference/p5/fill/">fill()</a> respectively. Custom properties
  can also

  be defined within <a href="/reference/p5/beginShape/">beginShape()</a> and

  <a href="/reference/p5/endShape/">endShape()</a>.</p>

  <p>The first parameter, <code>propertyName</code>, is a string with the
  property's name.

  This is the same variable name which should be declared in the shader, such as

  <code>in vec3 aProperty</code>, similar to .<code>setUniform()</code>.</p>

  <p>The second parameter, <code>data</code>, is the value assigned to the
  shader variable. This

  value will be applied to subsequent vertices created with

  <a href="/reference/p5/vertex/">vertex()</a>. It can be a Number or an array
  of numbers,

  and in the shader program the type can be declared according to the WebGL

  specification. Common types include <code>float</code>, <code>vec2</code>,
  <code>vec3</code>, <code>vec4</code> or matrices.</p>

  <p>See also the <a href="/reference/p5/vertexProperty/">vertexProperty()</a>
  method on

  <a href="/reference/p5/Geometry/">Geometry</a> objects.</p>
line: 1587
isConstructor: false
itemtype: method
example:
  - |-
    <div>
    <code>
    const vertSrc = `#version 300 es
     precision mediump float;
     uniform mat4 uModelViewMatrix;
     uniform mat4 uProjectionMatrix;

     in vec3 aPosition;
     in vec2 aOffset;

     void main(){
       vec4 positionVec4 = vec4(aPosition.xyz, 1.0);
       positionVec4.xy += aOffset;
       gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
     }
    `;

    const fragSrc = `#version 300 es
     precision mediump float;
     out vec4 outColor;
     void main(){
       outColor = vec4(0.0, 1.0, 1.0, 1.0);
     }
    `;

    function setup(){
      createCanvas(100, 100, WEBGL);

      // Create and use the custom shader.
      const myShader = createShader(vertSrc, fragSrc);
      shader(myShader);

      describe('A wobbly, cyan circle on a gray background.');
    }

    function draw(){
      // Set the styles
      background(125);
      noStroke();

      // Draw the circle.
      beginShape();
      for (let i = 0; i < 30; i++){
        const x = 40 * cos(i/30 * TWO_PI);
        const y = 40 * sin(i/30 * TWO_PI);

        // Apply some noise to the coordinates.
        const xOff = 10 * noise(x + millis()/1000) - 5;
        const yOff = 10 * noise(y + millis()/1000) - 5;

        // Apply these noise values to the following vertex.
        vertexProperty('aOffset', [xOff, yOff]);
        vertex(x, y);
      }
      endShape(CLOSE);
    }
    </code>
    </div>

    <div>
    <code>
    let myShader;
    const cols = 10;
    const rows = 10;
    const cellSize = 6;

    const vertSrc = `#version 300 es
      precision mediump float;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uModelViewMatrix;

      in vec3 aPosition;
      in vec3 aNormal;
      in vec3 aVertexColor;
      in float aDistance;

      out vec3 vVertexColor;

      void main(){
        vec4 positionVec4 = vec4(aPosition, 1.0);
        positionVec4.xyz += aDistance * aNormal * 2.0;;
        vVertexColor = aVertexColor;
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;

    const fragSrc = `#version 300 es
      precision mediump float;

      in vec3 vVertexColor;
      out vec4 outColor;

      void main(){
        outColor = vec4(vVertexColor, 1.0);
      }
    `;

    function setup(){
      createCanvas(100, 100, WEBGL);

      // Create and apply the custom shader.
      myShader = createShader(vertSrc, fragSrc);
      shader(myShader);
      noStroke();
      describe('A blue grid, which moves away from the mouse position, on a gray background.');
    }

    function draw(){
      background(200);

      // Draw the grid in the middle of the screen.
      translate(-cols*cellSize/2, -rows*cellSize/2);
      beginShape(QUADS);
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {

          // Calculate the cell position.
          let x = i * cellSize;
          let y = j * cellSize;

          fill(j/rows*255, j/cols*255, 255);

          // Calculate the distance from the corner of each cell to the mouse.
          let distance = dist(x, y, mouseX, mouseY);

          // Send the distance to the shader.
          vertexProperty('aDistance', min(distance, 100));

          vertex(x, y);
          vertex(x + cellSize, y);
          vertex(x + cellSize, y + cellSize);
          vertex(x, y + cellSize);
        }
      }
      endShape();
    }
    </code>
    </div>
class: p5
overloads:
  - params:
      - name: attributeName
        description: the name of the vertex attribute.
        type: String
      - name: data
        description: the data tied to the vertex attribute.
        type: 'Number|Number[]'
chainable: false
---


# vertexProperty
