---
title: baseFilterShader
module: 3D
submodule: Material
file: src/webgl/material.js
description: >
  <p>Get the base shader for filters.</p>

  <p>You can then call <a
  href="/reference/p5.Shader/modify/"><code>baseFilterShader().modify()</code></a>

  and change the following hook:</p>

  <table>

  <tr><th>Hook</th><th>Description</th></tr>

  <tr><td><p><code>vec4 getColor</code></p>

  </td><td><p>Output the final color for the current pixel. It takes in two
  parameters:

  <code>FilterInputs inputs</code>, and <code>in sampler2D canvasContent</code>,
  and must return a color

  as a <code>vec4</code>.</p>

  <p><code>FilterInputs inputs</code> is a scruct with the following
  properties:</p>

  <ul><li><code>vec2 texCoord</code>, the position on the canvas, with
  coordinates between 0 and 1. Calling

  <code>getTexture(canvasContent, texCoord)</code> returns the original color of
  the current pixel.</li><li><code>vec2 canvasSize</code>, the width and height
  of the sketch.</li><li><code>vec2 texelSize</code>, the size of one real pixel
  relative to the size of the whole canvas.

  This is equivalent to <code>1 / (canvasSize *
  pixelDensity)</code>.</li></ul><p><code>in sampler2D canvasContent</code> is a
  texture with the contents of the sketch, pre-filter. Call

  <code>getTexture(canvasContent, someCoordinate)</code> to retrieve the color
  of the sketch at that coordinate,

  with coordinate values between 0 and 1.</p>

  </td></tr>

  </table><p>Most of the time, you will need to write your hooks in GLSL ES
  version 300. If you

  are using WebGL 1, write your hooks in GLSL ES 100 instead.</p>
line: 1594
isConstructor: false
itemtype: method
example:
  - |-
    <div modernizr='webgl'>
    <code>
    let img;
    let myShader;

    async function setup() {
      img = await loadImage('/assets/bricks.jpg');
      createCanvas(100, 100, WEBGL);
      myShader = baseFilterShader().modify({
        uniforms: {
          'float time': () => millis()
        },
        'vec4 getColor': `(
          FilterInputs inputs,
          in sampler2D canvasContent
        ) {
          inputs.texCoord.y +=
            0.01 * sin(time * 0.001 + inputs.position.x * 5.0);
          return getTexture(canvasContent, inputs.texCoord);
        }`
      });
    }

    function draw() {
      image(img, -50, -50);
      filter(myShader);
      describe('an image of bricks, distorting over time');
    }
    </code>
    </div>
class: p5
return:
  description: The filter shader
  type: p5.Shader
overloads:
  - params: []
    return:
      description: The filter shader
      type: p5.Shader
chainable: false
---


# baseFilterShader
