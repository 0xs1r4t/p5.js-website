---
title: "Introduction to Shaders 2.0"
description: An introduction to the p5.js shading language.
category: shaders  
categoryIndex: 3
featuredImage: ../images/featured/intro-to-shaders.jpg
featuredImageAlt: A warped, wavy city street
relatedContent:
  examples:
    - en/11_3d/04_filter_shader/description
    - en/11_3d/05_adjusting_positions_with_a_shader/description
    - en/11_3d/06_framebuffer_blur/description
  references:
    - en/p5/p5shader
    - en/p5shader/modify
    - en/p5shader/inspecthooks
authors:
  - Luke Plowden
---


import EditableSketch from "../../../components/EditableSketch/index.astro";
import Callout from "../../../components/Callout/index.astro";
import AnnotatedCode from "../../../components/AnnotatedCode/index.astro";
import { Image } from "astro:assets";

## Introduction

In this tutorial, we will be exploring the p5.js shading language. This language is a simplified version of GLSL (OpenGL Shading Language), which is used in WebGL. Shaders are programs that run on the GPU (Graphics Processing Unit, sometimes known as a 'graphcs card') and are used to render graphics. They are used to create effects that are difficult to achieve with the traditional rendering pipeline. 

Practically, most of the effects that you can create with shaders can be achieved with the p5.js, but shaders can be more efficient and can be used to create more complex effects. Additionally, any effect you make with shaders can be used for different objects: for example, one shader which creates a wavy effect can be used on multiple objects, and the effect will be consistent across all of them.

## What is a Shader?

A shader is a program that runs on the GPU. There are two types of shaders: vertex shaders and fragment shaders. Vertex shaders are used to transform the vertices of a shape, while fragment shaders are used to determine the color of each pixel in a shape. Both are required to render anything in WebGL mode. Fortunately, p5.js provides some default shaders that you can use, so you don't have to write your own shaders if you don't want to. Take the following sketch...

<EditableSketch code={`
let myShader;

function setup() {
  createCanvas(200, 200, WEBGL);
}

function draw() {
  // shader(baseMaterialShader());
  lights();
  background(220);
  orbitControl();
  fill('blue');
  sphere(80);
}
`} />

A shader is caculating the lighting and shading of the blue fill, and another shader is drawing the stroke. Notice how if you uncomment the first line in the `draw()` function and click the play button, the sketch will look the same. That's because under the hood, p5.js has automatically applied the `baseMaterialShader()`. Alternatively, we can write `shader(baseColorShader());` on that line instead and the fill is now a solid color, not affected by lighting.

Previously, if you wanted to write your own shaders, you would have to use the `createShader()` and `loadShader()` functions. Recently, however, we have introduced a new way to write shaders in p5.js. This new way is called the p5.js shading language. This language is a simplified version of GLSL (OpenGL Shading Language), which is used in WebGL. The p5.js shading language is easier to use than GLSL, and it is designed to be used with p5.js.

<EditableSketch code={`
let myFilter;

function setup() {
  createCanvas(200, 200, WEBGL);
  myFilter = baseFilterShader().modify(() => {
    getColor((inputs, canvasContent) => {
      let color = texture(canvasContent, inputs.texCoord);
      return [1 - color.x, 1 - color.y, 1 - color.z, color.w];
    });
  });
}

function draw() {
  background(220);
  fill(255, 0, 0);
  rotateX(frameCount * 0.01);
  rotateY(frameCount * 0.01);
  push();
  noStroke();
  box(100);
  pop();
  // Apply the filter shader to everything that's been drawn
  filter(myFilter);
  box(50);
}
`} />